{"version":3,"sources":["../src/index.ts","../src/api.ts"],"sourcesContent":["import bodyParser from \"body-parser\";\nimport cors from \"cors\";\nimport express, { Request as ExpressRequest } from \"express\";\nimport multer from \"multer\";\nimport {\n    elizaLogger,\n    generateCaption,\n    generateImage,\n    Media,\n    getEmbeddingZeroVector\n} from \"@elizaos/core\";\nimport { composeContext } from \"@elizaos/core\";\nimport { generateMessageResponse } from \"@elizaos/core\";\nimport { messageCompletionFooter } from \"@elizaos/core\";\nimport { AgentRuntime } from \"@elizaos/core\";\nimport {\n    Content,\n    Memory,\n    ModelClass,\n    Client,\n    IAgentRuntime,\n} from \"@elizaos/core\";\nimport { stringToUuid } from \"@elizaos/core\";\nimport { settings } from \"@elizaos/core\";\nimport { createApiRouter } from \"./api.ts\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nconst storage = multer.diskStorage({\n    destination: (req, file, cb) => {\n        const uploadDir = path.join(process.cwd(), \"data\", \"uploads\");\n        // Create the directory if it doesn't exist\n        if (!fs.existsSync(uploadDir)) {\n            fs.mkdirSync(uploadDir, { recursive: true });\n        }\n        cb(null, uploadDir);\n    },\n    filename: (req, file, cb) => {\n        const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;\n        cb(null, `${uniqueSuffix}-${file.originalname}`);\n    },\n});\n\nconst upload = multer({ storage });\n\nexport const messageHandlerTemplate =\n    // {{goals}}\n    `# Action Examples\n{{actionExamples}}\n(Action examples are for reference only. Do not use the information from them in your response.)\n\n# Knowledge\n{{knowledge}}\n\n# Task: Generate dialog and actions for the character {{agentName}}.\nAbout {{agentName}}:\n{{bio}}\n{{lore}}\n\n{{providers}}\n\n{{attachments}}\n\n# Capabilities\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n{{messageDirections}}\n\n{{recentMessages}}\n\n{{actions}}\n\n# Instructions: Write the next message for {{agentName}}.\n` + messageCompletionFooter;\n\nexport class DirectClient {\n    public app: express.Application;\n    private agents: Map<string, AgentRuntime>; // container management\n    private server: any; // Store server instance\n    public startAgent: Function; // Store startAgent functor\n\n    constructor() {\n        elizaLogger.log(\"DirectClient constructor\");\n        this.app = express();\n        this.app.use(cors());\n        this.agents = new Map();\n\n        this.app.use(bodyParser.json());\n        this.app.use(bodyParser.urlencoded({ extended: true }));\n\n        // Serve both uploads and generated images\n        this.app.use(\n            \"/media/uploads\",\n            express.static(path.join(process.cwd(), \"/data/uploads\"))\n        );\n        this.app.use(\n            \"/media/generated\",\n            express.static(path.join(process.cwd(), \"/generatedImages\"))\n        );\n\n        const apiRouter = createApiRouter(this.agents, this);\n        this.app.use(apiRouter);\n\n        // Define an interface that extends the Express Request interface\n        interface CustomRequest extends ExpressRequest {\n            file?: Express.Multer.File;\n        }\n\n        // Update the route handler to use CustomRequest instead of express.Request\n        this.app.post(\n            \"/:agentId/whisper\",\n            upload.single(\"file\"),\n            async (req: CustomRequest, res: express.Response) => {\n                const audioFile = req.file; // Access the uploaded file using req.file\n                const agentId = req.params.agentId;\n\n                if (!audioFile) {\n                    res.status(400).send(\"No audio file provided\");\n                    return;\n                }\n\n                let runtime = this.agents.get(agentId);\n\n                // if runtime is null, look for runtime with the same name\n                if (!runtime) {\n                    runtime = Array.from(this.agents.values()).find(\n                        (a) =>\n                            a.character.name.toLowerCase() ===\n                            agentId.toLowerCase()\n                    );\n                }\n\n                if (!runtime) {\n                    res.status(404).send(\"Agent not found\");\n                    return;\n                }\n\n                const formData = new FormData();\n                const audioBlob = new Blob([audioFile.buffer], {\n                    type: audioFile.mimetype,\n                });\n                formData.append(\"file\", audioBlob, audioFile.originalname);\n                formData.append(\"model\", \"whisper-1\");\n\n                const response = await fetch(\n                    \"https://api.openai.com/v1/audio/transcriptions\",\n                    {\n                        method: \"POST\",\n                        headers: {\n                            Authorization: `Bearer ${runtime.token}`,\n                        },\n                        body: formData,\n                    }\n                );\n\n                const data = await response.json();\n                res.json(data);\n            }\n        );\n\n        this.app.post(\n            \"/:agentId/message\",\n            upload.single(\"file\"),\n            async (req: express.Request, res: express.Response) => {\n                const agentId = req.params.agentId;\n                const roomId = stringToUuid(\n                    req.body.roomId ?? \"default-room-\" + agentId\n                );\n                const userId = stringToUuid(req.body.userId ?? \"user\");\n\n                let runtime = this.agents.get(agentId);\n\n                // if runtime is null, look for runtime with the same name\n                if (!runtime) {\n                    runtime = Array.from(this.agents.values()).find(\n                        (a) =>\n                            a.character.name.toLowerCase() ===\n                            agentId.toLowerCase()\n                    );\n                }\n\n                if (!runtime) {\n                    res.status(404).send(\"Agent not found\");\n                    return;\n                }\n\n                await runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    req.body.userName,\n                    req.body.name,\n                    \"direct\"\n                );\n\n                const text = req.body.text;\n                const messageId = stringToUuid(Date.now().toString());\n\n                const attachments: Media[] = [];\n                if (req.file) {\n                    const filePath = path.join(\n                        process.cwd(),\n                        \"agent\",\n                        \"data\",\n                        \"uploads\",\n                        req.file.filename\n                    );\n                    attachments.push({\n                        id: Date.now().toString(),\n                        url: filePath,\n                        title: req.file.originalname,\n                        source: \"direct\",\n                        description: `Uploaded file: ${req.file.originalname}`,\n                        text: \"\",\n                        contentType: req.file.mimetype,\n                    });\n                }\n\n                const content: Content = {\n                    text,\n                    attachments,\n                    source: \"direct\",\n                    inReplyTo: undefined,\n                };\n\n                const userMessage = {\n                    content,\n                    userId,\n                    roomId,\n                    agentId: runtime.agentId,\n                };\n\n                const memory: Memory = {\n                    id: stringToUuid(messageId + \"-\" + userId),\n                    ...userMessage,\n                    agentId: runtime.agentId,\n                    userId,\n                    roomId,\n                    content,\n                    createdAt: Date.now(),\n                };\n\n                await runtime.messageManager.addEmbeddingToMemory(memory);\n                await runtime.messageManager.createMemory(memory);\n\n                let state = await runtime.composeState(userMessage, {\n                    agentName: runtime.character.name,\n                });\n\n                const context = composeContext({\n                    state,\n                    template: messageHandlerTemplate,\n                });\n\n                const response = await generateMessageResponse({\n                    runtime: runtime,\n                    context,\n                    modelClass: ModelClass.LARGE,\n                });\n\n                if (!response) {\n                    res.status(500).send(\n                        \"No response from generateMessageResponse\"\n                    );\n                    return;\n                }\n\n                // save response to memory\n                const responseMessage: Memory = {\n                    id: stringToUuid(messageId + \"-\" + runtime.agentId),\n                    ...userMessage,\n                    userId: runtime.agentId,\n                    content: response,\n                    embedding: getEmbeddingZeroVector(),\n                    createdAt: Date.now(),\n                };\n\n                await runtime.messageManager.createMemory(responseMessage);\n\n                state = await runtime.updateRecentMessageState(state);\n\n                let message = null as Content | null;\n\n                await runtime.processActions(\n                    memory,\n                    [responseMessage],\n                    state,\n                    async (newMessages) => {\n                        message = newMessages;\n                        return [memory];\n                    }\n                );\n\n                await runtime.evaluate(memory, state);\n\n                // Check if we should suppress the initial message\n                const action = runtime.actions.find(\n                    (a) => a.name === response.action\n                );\n                const shouldSuppressInitialMessage =\n                    action?.suppressInitialMessage;\n\n                if (!shouldSuppressInitialMessage) {\n                    if (message) {\n                        res.json([response, message]);\n                    } else {\n                        res.json([response]);\n                    }\n                } else {\n                    if (message) {\n                        res.json([message]);\n                    } else {\n                        res.json([]);\n                    }\n                }\n            }\n        );\n\n        this.app.post(\n            \"/:agentId/image\",\n            async (req: express.Request, res: express.Response) => {\n                const agentId = req.params.agentId;\n                const agent = this.agents.get(agentId);\n                if (!agent) {\n                    res.status(404).send(\"Agent not found\");\n                    return;\n                }\n\n                const images = await generateImage({ ...req.body }, agent);\n                const imagesRes: { image: string; caption: string }[] = [];\n                if (images.data && images.data.length > 0) {\n                    for (let i = 0; i < images.data.length; i++) {\n                        const caption = await generateCaption(\n                            { imageUrl: images.data[i] },\n                            agent\n                        );\n                        imagesRes.push({\n                            image: images.data[i],\n                            caption: caption.title,\n                        });\n                    }\n                }\n                res.json({ images: imagesRes });\n            }\n        );\n\n        this.app.post(\n            \"/fine-tune\",\n            async (req: express.Request, res: express.Response) => {\n                try {\n                    const response = await fetch(\n                        \"https://api.bageldb.ai/api/v1/asset\",\n                        {\n                            method: \"POST\",\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                                \"X-API-KEY\": `${process.env.BAGEL_API_KEY}`,\n                            },\n                            body: JSON.stringify(req.body),\n                        }\n                    );\n\n                    const data = await response.json();\n                    res.json(data);\n                } catch (error) {\n                    res.status(500).json({\n                        error: \"Please create an account at bakery.bagel.net and get an API key. Then set the BAGEL_API_KEY environment variable.\",\n                        details: error.message,\n                    });\n                }\n            }\n        );\n        this.app.get(\n            \"/fine-tune/:assetId\",\n            async (req: express.Request, res: express.Response) => {\n                const assetId = req.params.assetId;\n                const downloadDir = path.join(\n                    process.cwd(),\n                    \"downloads\",\n                    assetId\n                );\n\n                console.log(\"Download directory:\", downloadDir);\n\n                try {\n                    console.log(\"Creating directory...\");\n                    await fs.promises.mkdir(downloadDir, { recursive: true });\n\n                    console.log(\"Fetching file...\");\n                    const fileResponse = await fetch(\n                        `https://api.bageldb.ai/api/v1/asset/${assetId}/download`,\n                        {\n                            headers: {\n                                \"X-API-KEY\": `${process.env.BAGEL_API_KEY}`,\n                            },\n                        }\n                    );\n\n                    if (!fileResponse.ok) {\n                        throw new Error(\n                            `API responded with status ${fileResponse.status}: ${await fileResponse.text()}`\n                        );\n                    }\n\n                    console.log(\"Response headers:\", fileResponse.headers);\n\n                    const fileName =\n                        fileResponse.headers\n                            .get(\"content-disposition\")\n                            ?.split(\"filename=\")[1]\n                            ?.replace(/\"/g, /* \" */ \"\") || \"default_name.txt\";\n\n                    console.log(\"Saving as:\", fileName);\n\n                    const arrayBuffer = await fileResponse.arrayBuffer();\n                    const buffer = Buffer.from(arrayBuffer);\n\n                    const filePath = path.join(downloadDir, fileName);\n                    console.log(\"Full file path:\", filePath);\n\n                    await fs.promises.writeFile(filePath, buffer);\n\n                    // Verify file was written\n                    const stats = await fs.promises.stat(filePath);\n                    console.log(\n                        \"File written successfully. Size:\",\n                        stats.size,\n                        \"bytes\"\n                    );\n\n                    res.json({\n                        success: true,\n                        message: \"Single file downloaded successfully\",\n                        downloadPath: downloadDir,\n                        fileCount: 1,\n                        fileName: fileName,\n                        fileSize: stats.size,\n                    });\n                } catch (error) {\n                    console.error(\"Detailed error:\", error);\n                    res.status(500).json({\n                        error: \"Failed to download files from BagelDB\",\n                        details: error.message,\n                        stack: error.stack,\n                    });\n                }\n            }\n        );\n\n        this.app.post(\"/:agentId/speak\", async (req, res) => {\n            const agentId = req.params.agentId;\n            const roomId = stringToUuid(req.body.roomId ?? \"default-room-\" + agentId);\n            const userId = stringToUuid(req.body.userId ?? \"user\");\n            const text = req.body.text;\n\n            if (!text) {\n                res.status(400).send(\"No text provided\");\n                return;\n            }\n\n            let runtime = this.agents.get(agentId);\n\n            // if runtime is null, look for runtime with the same name\n            if (!runtime) {\n                runtime = Array.from(this.agents.values()).find(\n                    (a) => a.character.name.toLowerCase() === agentId.toLowerCase()\n                );\n            }\n\n            if (!runtime) {\n                res.status(404).send(\"Agent not found\");\n                return;\n            }\n\n            try {\n                // Process message through agent (same as /message endpoint)\n                await runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    req.body.userName,\n                    req.body.name,\n                    \"direct\"\n                );\n\n                const messageId = stringToUuid(Date.now().toString());\n\n                const content: Content = {\n                    text,\n                    attachments: [],\n                    source: \"direct\",\n                    inReplyTo: undefined,\n                };\n\n                const userMessage = {\n                    content,\n                    userId,\n                    roomId,\n                    agentId: runtime.agentId,\n                };\n\n                const memory: Memory = {\n                    id: messageId,\n                    agentId: runtime.agentId,\n                    userId,\n                    roomId,\n                    content,\n                    createdAt: Date.now(),\n                };\n\n                await runtime.messageManager.createMemory(memory);\n\n                const state = await runtime.composeState(userMessage, {\n                    agentName: runtime.character.name,\n                });\n\n                const context = composeContext({\n                    state,\n                    template: messageHandlerTemplate,\n                });\n\n                const response = await generateMessageResponse({\n                    runtime: runtime,\n                    context,\n                    modelClass: ModelClass.LARGE,\n                });\n\n                // save response to memory\n                const responseMessage = {\n                    ...userMessage,\n                    userId: runtime.agentId,\n                    content: response,\n                };\n\n                await runtime.messageManager.createMemory(responseMessage);\n\n                if (!response) {\n                    res.status(500).send(\"No response from generateMessageResponse\");\n                    return;\n                }\n\n                await runtime.evaluate(memory, state);\n\n                const _result = await runtime.processActions(\n                    memory,\n                    [responseMessage],\n                    state,\n                    async () => {\n                        return [memory];\n                    }\n                );\n\n                // Get the text to convert to speech\n                const textToSpeak = response.text;\n\n                // Convert to speech using ElevenLabs\n                const elevenLabsApiUrl = `https://api.elevenlabs.io/v1/text-to-speech/${process.env.ELEVENLABS_VOICE_ID}`;\n                const apiKey = process.env.ELEVENLABS_XI_API_KEY;\n\n                if (!apiKey) {\n                    throw new Error(\"ELEVENLABS_XI_API_KEY not configured\");\n                }\n\n                const speechResponse = await fetch(elevenLabsApiUrl, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        \"xi-api-key\": apiKey,\n                    },\n                    body: JSON.stringify({\n                        text: textToSpeak,\n                        model_id: process.env.ELEVENLABS_MODEL_ID || \"eleven_multilingual_v2\",\n                        voice_settings: {\n                            stability: parseFloat(process.env.ELEVENLABS_VOICE_STABILITY || \"0.5\"),\n                            similarity_boost: parseFloat(process.env.ELEVENLABS_VOICE_SIMILARITY_BOOST || \"0.9\"),\n                            style: parseFloat(process.env.ELEVENLABS_VOICE_STYLE || \"0.66\"),\n                            use_speaker_boost: process.env.ELEVENLABS_VOICE_USE_SPEAKER_BOOST === \"true\",\n                        },\n                    }),\n                });\n\n                if (!speechResponse.ok) {\n                    throw new Error(`ElevenLabs API error: ${speechResponse.statusText}`);\n                }\n\n                const audioBuffer = await speechResponse.arrayBuffer();\n\n                // Set appropriate headers for audio streaming\n                res.set({\n                    'Content-Type': 'audio/mpeg',\n                    'Transfer-Encoding': 'chunked'\n                });\n\n                res.send(Buffer.from(audioBuffer));\n\n            } catch (error) {\n                console.error(\"Error processing message or generating speech:\", error);\n                res.status(500).json({\n                    error: \"Error processing message or generating speech\",\n                    details: error.message\n                });\n            }\n        });\n    }\n\n    // agent/src/index.ts:startAgent calls this\n    public registerAgent(runtime: AgentRuntime) {\n        this.agents.set(runtime.agentId, runtime);\n    }\n\n    public unregisterAgent(runtime: AgentRuntime) {\n        this.agents.delete(runtime.agentId);\n    }\n\n    public start(port: number) {\n        this.server = this.app.listen(port, () => {\n            elizaLogger.success(\n                `REST API bound to 0.0.0.0:${port}. If running locally, access it at http://localhost:${port}.`\n            );\n        });\n\n        // Handle graceful shutdown\n        const gracefulShutdown = () => {\n            elizaLogger.log(\"Received shutdown signal, closing server...\");\n            this.server.close(() => {\n                elizaLogger.success(\"Server closed successfully\");\n                process.exit(0);\n            });\n\n            // Force close after 5 seconds if server hasn't closed\n            setTimeout(() => {\n                elizaLogger.error(\n                    \"Could not close connections in time, forcefully shutting down\"\n                );\n                process.exit(1);\n            }, 5000);\n        };\n\n        // Handle different shutdown signals\n        process.on(\"SIGTERM\", gracefulShutdown);\n        process.on(\"SIGINT\", gracefulShutdown);\n    }\n\n    public stop() {\n        if (this.server) {\n            this.server.close(() => {\n                elizaLogger.success(\"Server stopped\");\n            });\n        }\n    }\n}\n\nexport const DirectClientInterface: Client = {\n    start: async (_runtime: IAgentRuntime) => {\n        elizaLogger.log(\"DirectClientInterface start\");\n        const client = new DirectClient();\n        const serverPort = parseInt(settings.SERVER_PORT || \"3000\");\n        client.start(serverPort);\n        return client;\n    },\n    stop: async (_runtime: IAgentRuntime, client?: Client) => {\n        if (client instanceof DirectClient) {\n            client.stop();\n        }\n    },\n};\n\nexport default DirectClientInterface;\n","import express from \"express\";\nimport bodyParser from \"body-parser\";\nimport cors from \"cors\";\n\nimport {\n    AgentRuntime,\n    elizaLogger,\n    getEnvVariable,\n    validateCharacterConfig,\n} from \"@elizaos/core\";\n\nimport { REST, Routes } from \"discord.js\";\nimport { DirectClient } from \".\";\n\nexport function createApiRouter(\n    agents: Map<string, AgentRuntime>,\n    directClient: DirectClient\n) {\n    const router = express.Router();\n\n    router.use(cors());\n    router.use(bodyParser.json());\n    router.use(bodyParser.urlencoded({ extended: true }));\n    router.use(\n        express.json({\n            limit: getEnvVariable(\"EXPRESS_MAX_PAYLOAD\") || \"100kb\",\n        })\n    );\n\n    router.get(\"/\", (req, res) => {\n        res.send(\"Welcome, this is the REST API!\");\n    });\n\n    router.get(\"/hello\", (req, res) => {\n        res.json({ message: \"Hello World!\" });\n    });\n\n    router.get(\"/agents\", (req, res) => {\n        const agentsList = Array.from(agents.values()).map((agent) => ({\n            id: agent.agentId,\n            name: agent.character.name,\n            clients: Object.keys(agent.clients),\n        }));\n        res.json({ agents: agentsList });\n    });\n\n    router.get(\"/agents/:agentId\", (req, res) => {\n        const agentId = req.params.agentId;\n        const agent = agents.get(agentId);\n\n        if (!agent) {\n            res.status(404).json({ error: \"Agent not found\" });\n            return;\n        }\n\n        res.json({\n            id: agent.agentId,\n            character: agent.character,\n        });\n    });\n\n    router.post(\"/agents/:agentId/set\", async (req, res) => {\n        const agentId = req.params.agentId;\n        console.log(\"agentId\", agentId);\n        let agent: AgentRuntime = agents.get(agentId);\n\n        // update character\n        if (agent) {\n            // stop agent\n            agent.stop();\n            directClient.unregisterAgent(agent);\n            // if it has a different name, the agentId will change\n        }\n\n        // load character from body\n        const character = req.body;\n        try {\n            validateCharacterConfig(character);\n        } catch (e) {\n            elizaLogger.error(`Error parsing character: ${e}`);\n            res.status(400).json({\n                success: false,\n                message: e.message,\n            });\n            return;\n        }\n\n        // start it up (and register it)\n        agent = await directClient.startAgent(character);\n        elizaLogger.log(`${character.name} started`);\n\n        res.json({\n            id: character.id,\n            character: character,\n        });\n    });\n\n    router.get(\"/agents/:agentId/channels\", async (req, res) => {\n        const agentId = req.params.agentId;\n        const runtime = agents.get(agentId);\n\n        if (!runtime) {\n            res.status(404).json({ error: \"Runtime not found\" });\n            return;\n        }\n\n        const API_TOKEN = runtime.getSetting(\"DISCORD_API_TOKEN\") as string;\n        const rest = new REST({ version: \"10\" }).setToken(API_TOKEN);\n\n        try {\n            const guilds = (await rest.get(Routes.userGuilds())) as Array<any>;\n\n            res.json({\n                id: runtime.agentId,\n                guilds: guilds,\n                serverCount: guilds.length,\n            });\n        } catch (error) {\n            console.error(\"Error fetching guilds:\", error);\n            res.status(500).json({ error: \"Failed to fetch guilds\" });\n        }\n    });\n\n    return router;\n}\n"],"mappings":"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","names":["bodyParser","cors","express","elizaLogger","elizaLogger","express","cors","bodyParser"]}