{"version":3,"sources":["../streams/index.ts","../core/index.ts","../util/retry-with-exponential-backoff.ts","../util/delay.ts","../util/retry-error.ts","../core/telemetry/assemble-operation-name.ts","../core/telemetry/get-base-telemetry-attributes.ts","../core/telemetry/get-tracer.ts","../core/telemetry/noop-tracer.ts","../core/telemetry/record-span.ts","../core/telemetry/select-telemetry-attributes.ts","../core/embed/embed.ts","../core/util/split-array.ts","../core/embed/embed-many.ts","../core/generate-object/generate-object.ts","../util/download-error.ts","../util/download.ts","../core/util/detect-image-mimetype.ts","../core/prompt/data-content.ts","../core/prompt/invalid-data-content-error.ts","../core/prompt/invalid-message-role-error.ts","../core/prompt/split-data-url.ts","../core/prompt/convert-to-language-model-prompt.ts","../errors/invalid-argument-error.ts","../core/prompt/prepare-call-settings.ts","../core/prompt/standardize-prompt.ts","../core/prompt/message.ts","../core/types/provider-metadata.ts","../core/types/json-value.ts","../core/prompt/content-part.ts","../core/prompt/tool-result-content.ts","../core/prompt/detect-prompt-type.ts","../core/prompt/attachments-to-parts.ts","../core/prompt/message-conversion-error.ts","../core/prompt/convert-to-core-messages.ts","../core/types/usage.ts","../core/util/prepare-response-headers.ts","../core/generate-object/inject-json-instruction.ts","../core/generate-object/no-object-generated-error.ts","../core/generate-object/output-strategy.ts","../core/util/async-iterable-stream.ts","../core/generate-object/validate-object-generation-input.ts","../core/generate-object/stream-object.ts","../util/create-resolvable-promise.ts","../util/delayed-promise.ts","../core/util/now.ts","../core/util/prepare-outgoing-http-headers.ts","../core/util/write-to-server-response.ts","../core/generate-text/generate-text.ts","../errors/index.ts","../errors/invalid-tool-arguments-error.ts","../errors/no-such-tool-error.ts","../core/prompt/prepare-tools-and-tool-choice.ts","../core/util/is-non-empty-object.ts","../core/util/split-on-last-whitespace.ts","../core/util/remove-text-after-last-whitespace.ts","../core/generate-text/parse-tool-call.ts","../core/generate-text/to-response-messages.ts","../core/generate-text/stream-text.ts","../core/util/create-stitchable-stream.ts","../core/util/merge-streams.ts","../core/generate-text/run-tools-transformation.ts","../core/middleware/wrap-language-model.ts","../core/registry/custom-provider.ts","../core/registry/no-such-provider-error.ts","../core/registry/provider-registry.ts","../core/tool/tool.ts","../core/util/cosine-similarity.ts","../streams/ai-stream.ts","../streams/stream-data.ts","../util/constants.ts","../streams/anthropic-stream.ts","../streams/assistant-response.ts","../streams/aws-bedrock-stream.ts","../streams/cohere-stream.ts","../streams/google-generative-ai-stream.ts","../streams/huggingface-stream.ts","../streams/inkeep-stream.ts","../streams/langchain-adapter.ts","../streams/llamaindex-adapter.ts","../streams/langchain-stream.ts","../streams/mistral-stream.ts","../streams/openai-stream.ts","../streams/replicate-stream.ts","../streams/stream-to-response.ts","../streams/streaming-text-response.ts"],"sourcesContent":["// forwarding exports from ui-utils:\nexport {\n  formatStreamPart,\n  parseStreamPart,\n  readDataStream,\n  processDataProtocolResponse,\n} from '@ai-sdk/ui-utils';\nexport type {\n  AssistantStatus,\n  UseAssistantOptions,\n  Message,\n  CreateMessage,\n  DataMessage,\n  AssistantMessage,\n  JSONValue,\n  ChatRequest,\n  ChatRequestOptions,\n  Function,\n  FunctionCall,\n  FunctionCallHandler,\n  ToolInvocation,\n  Tool,\n  ToolCall,\n  ToolCallHandler,\n  ToolChoice,\n  StreamPart,\n  IdGenerator,\n  RequestOptions,\n  Attachment,\n} from '@ai-sdk/ui-utils';\n\nimport { generateId as generateIdImpl } from '@ai-sdk/provider-utils';\nexport const generateId = generateIdImpl;\n\n/**\n@deprecated Use `generateId` instead.\n */\n// TODO remove nanoid export (breaking change)\nexport const nanoid = generateIdImpl;\n\nexport * from '../core/index';\nexport * from '../errors/index';\n\nexport * from './ai-stream';\nexport * from './anthropic-stream';\nexport * from './assistant-response';\nexport * from './aws-bedrock-stream';\nexport * from './cohere-stream';\nexport * from './google-generative-ai-stream';\nexport * from './huggingface-stream';\nexport * from './inkeep-stream';\nexport * as LangChainAdapter from './langchain-adapter';\nexport * as LlamaIndexAdapter from './llamaindex-adapter';\nexport * from './langchain-stream';\nexport * from './mistral-stream';\nexport * from './openai-stream';\nexport * from './replicate-stream';\nexport * from './stream-data';\nexport * from './stream-to-response';\nexport * from './streaming-text-response';\n","export { jsonSchema } from '@ai-sdk/ui-utils';\nexport type { DeepPartial, Schema } from '@ai-sdk/ui-utils';\nexport * from './embed';\nexport * from './generate-object';\nexport * from './generate-text';\nexport * from './middleware';\nexport * from './prompt';\nexport * from './registry';\nexport * from './tool';\nexport * from './types';\nexport { cosineSimilarity } from './util/cosine-similarity';\n","import { APICallError } from '@ai-sdk/provider';\nimport { getErrorMessage, isAbortError } from '@ai-sdk/provider-utils';\nimport { delay } from './delay';\nimport { RetryError } from './retry-error';\n\nexport type RetryFunction = <OUTPUT>(\n  fn: () => PromiseLike<OUTPUT>,\n) => PromiseLike<OUTPUT>;\n\n/**\nThe `retryWithExponentialBackoff` strategy retries a failed API call with an exponential backoff.\nYou can configure the maximum number of retries, the initial delay, and the backoff factor.\n */\nexport const retryWithExponentialBackoff =\n  ({\n    maxRetries = 2,\n    initialDelayInMs = 2000,\n    backoffFactor = 2,\n  } = {}): RetryFunction =>\n  async <OUTPUT>(f: () => PromiseLike<OUTPUT>) =>\n    _retryWithExponentialBackoff(f, {\n      maxRetries,\n      delayInMs: initialDelayInMs,\n      backoffFactor,\n    });\n\nasync function _retryWithExponentialBackoff<OUTPUT>(\n  f: () => PromiseLike<OUTPUT>,\n  {\n    maxRetries,\n    delayInMs,\n    backoffFactor,\n  }: { maxRetries: number; delayInMs: number; backoffFactor: number },\n  errors: unknown[] = [],\n): Promise<OUTPUT> {\n  try {\n    return await f();\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error; // don't retry when the request was aborted\n    }\n\n    if (maxRetries === 0) {\n      throw error; // don't wrap the error when retries are disabled\n    }\n\n    const errorMessage = getErrorMessage(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: 'maxRetriesExceeded',\n        errors: newErrors,\n      });\n    }\n\n    if (\n      error instanceof Error &&\n      APICallError.isAPICallError(error) &&\n      error.isRetryable === true &&\n      tryNumber <= maxRetries\n    ) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors,\n      );\n    }\n\n    if (tryNumber === 1) {\n      throw error; // don't wrap the error when a non-retryable error occurs on the first try\n    }\n\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: 'errorNotRetryable',\n      errors: newErrors,\n    });\n  }\n}\n","export async function delay(delayInMs?: number): Promise<void> {\n  return delayInMs === undefined\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_RetryError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport type RetryErrorReason =\n  | 'maxRetriesExceeded'\n  | 'errorNotRetryable'\n  | 'abort';\n\nexport class RetryError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  // note: property order determines debugging output\n  readonly reason: RetryErrorReason;\n  readonly lastError: unknown;\n  readonly errors: Array<unknown>;\n\n  constructor({\n    message,\n    reason,\n    errors,\n  }: {\n    message: string;\n    reason: RetryErrorReason;\n    errors: Array<unknown>;\n  }) {\n    super({ name, message });\n\n    this.reason = reason;\n    this.errors = errors;\n\n    // separate our last error to make debugging via log easier:\n    this.lastError = errors[errors.length - 1];\n  }\n\n  static isInstance(error: unknown): error is RetryError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isRetryError(error: unknown): error is RetryError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as RetryError).reason === 'string' &&\n      Array.isArray((error as RetryError).errors)\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      reason: this.reason,\n      lastError: this.lastError,\n      errors: this.errors,\n    };\n  }\n}\n","import { TelemetrySettings } from './telemetry-settings';\n\nexport function assembleOperationName({\n  operationId,\n  telemetry,\n}: {\n  operationId: string;\n  telemetry?: TelemetrySettings;\n}) {\n  return {\n    // standardized operation and resource name:\n    'operation.name': `${operationId}${\n      telemetry?.functionId != null ? ` ${telemetry.functionId}` : ''\n    }`,\n    'resource.name': telemetry?.functionId,\n\n    // detailed, AI SDK specific data:\n    'ai.operationId': operationId,\n    'ai.telemetry.functionId': telemetry?.functionId,\n  };\n}\n","import { Attributes } from '@opentelemetry/api';\nimport { CallSettings } from '../prompt/call-settings';\nimport { TelemetrySettings } from './telemetry-settings';\n\nexport function getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers,\n}: {\n  model: { modelId: string; provider: string };\n  settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n  telemetry: TelemetrySettings | undefined;\n  headers: Record<string, string | undefined> | undefined;\n}): Attributes {\n  return {\n    'ai.model.provider': model.provider,\n    'ai.model.id': model.modelId,\n\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {} as Attributes),\n\n    // add metadata as attributes:\n    ...Object.entries(telemetry?.metadata ?? {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {} as Attributes,\n    ),\n\n    // request headers\n    ...Object.entries(headers ?? {}).reduce((attributes, [key, value]) => {\n      if (value !== undefined) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {} as Attributes),\n  };\n}\n","import { Tracer, trace } from '@opentelemetry/api';\nimport { noopTracer } from './noop-tracer';\n\nexport function getTracer({\n  isEnabled = false,\n  tracer,\n}: {\n  isEnabled?: boolean;\n  tracer?: Tracer;\n} = {}): Tracer {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n\n  if (tracer) {\n    return tracer;\n  }\n\n  return trace.getTracer('ai');\n}\n","import { Span, SpanContext, Tracer } from '@opentelemetry/api';\n\n/**\n * Tracer implementation that does nothing (null object).\n */\nexport const noopTracer: Tracer = {\n  startSpan(): Span {\n    return noopSpan;\n  },\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: unknown,\n    arg1: unknown,\n    arg2?: unknown,\n    arg3?: F,\n  ): ReturnType<any> {\n    if (typeof arg1 === 'function') {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === 'function') {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === 'function') {\n      return arg3(noopSpan);\n    }\n  },\n};\n\nconst noopSpan: Span = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  },\n};\n\nconst noopSpanContext: SpanContext = {\n  traceId: '',\n  spanId: '',\n  traceFlags: 0,\n};\n","import { Attributes, Span, Tracer, SpanStatusCode } from '@opentelemetry/api';\n\nexport function recordSpan<T>({\n  name,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true,\n}: {\n  name: string;\n  tracer: Tracer;\n  attributes: Attributes;\n  fn: (span: Span) => Promise<T>;\n  endWhenDone?: boolean;\n}) {\n  return tracer.startActiveSpan(name, { attributes }, async span => {\n    try {\n      const result = await fn(span);\n\n      if (endWhenDone) {\n        span.end();\n      }\n\n      return result;\n    } catch (error) {\n      try {\n        if (error instanceof Error) {\n          span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          });\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: error.message,\n          });\n        } else {\n          span.setStatus({ code: SpanStatusCode.ERROR });\n        }\n      } finally {\n        // always stop the span when there is an error:\n        span.end();\n      }\n\n      throw error;\n    }\n  });\n}\n","import type { Attributes, AttributeValue } from '@opentelemetry/api';\nimport type { TelemetrySettings } from './telemetry-settings';\n\nexport function selectTelemetryAttributes({\n  telemetry,\n  attributes,\n}: {\n  telemetry?: TelemetrySettings;\n  attributes: {\n    [attributeKey: string]:\n      | AttributeValue\n      | { input: () => AttributeValue | undefined }\n      | { output: () => AttributeValue | undefined }\n      | undefined;\n  };\n}): Attributes {\n  // when telemetry is disabled, return an empty object to avoid serialization overhead:\n  if (telemetry?.isEnabled !== true) {\n    return {};\n  }\n\n  return Object.entries(attributes).reduce((attributes, [key, value]) => {\n    if (value === undefined) {\n      return attributes;\n    }\n\n    // input value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'input' in value &&\n      typeof value.input === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordInputs === false) {\n        return attributes;\n      }\n\n      const result = value.input();\n\n      return result === undefined\n        ? attributes\n        : { ...attributes, [key]: result };\n    }\n\n    // output value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'output' in value &&\n      typeof value.output === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordOutputs === false) {\n        return attributes;\n      }\n\n      const result = value.output();\n\n      return result === undefined\n        ? attributes\n        : { ...attributes, [key]: result };\n    }\n\n    // value is an attribute value already:\n    return { ...attributes, [key]: value };\n  }, {});\n}\n","import { retryWithExponentialBackoff } from '../../util/retry-with-exponential-backoff';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { EmbeddingModel } from '../types';\nimport { EmbedResult } from './embed-result';\n\n/**\nEmbed a value using an embedding model. The type of the value is defined by the embedding model.\n\n@param model - The embedding model to use.\n@param value - The value that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embedding, the value, and additional information.\n */\nexport async function embed<VALUE>({\n  model,\n  value,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel<VALUE>;\n\n  /**\nThe value that should be embedded.\n   */\n  value: VALUE;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n}): Promise<EmbedResult<VALUE>> {\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embed',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embed', telemetry }),\n        ...baseTelemetryAttributes,\n        'ai.value': { input: () => JSON.stringify(value) },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n\n      const { embedding, usage, rawResponse } = await retry(() =>\n        // nested spans to align with the embedMany telemetry data:\n        recordSpan({\n          name: 'ai.embed.doEmbed',\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: 'ai.embed.doEmbed',\n                telemetry,\n              }),\n              ...baseTelemetryAttributes,\n              // specific settings that only make sense on the outer level:\n              'ai.values': { input: () => [JSON.stringify(value)] },\n            },\n          }),\n          tracer,\n          fn: async doEmbedSpan => {\n            const modelResponse = await model.doEmbed({\n              values: [value],\n              abortSignal,\n              headers,\n            });\n\n            const embedding = modelResponse.embeddings[0];\n            const usage = modelResponse.usage ?? { tokens: NaN };\n\n            doEmbedSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  'ai.embeddings': {\n                    output: () =>\n                      modelResponse.embeddings.map(embedding =>\n                        JSON.stringify(embedding),\n                      ),\n                  },\n                  'ai.usage.tokens': usage.tokens,\n                },\n              }),\n            );\n\n            return {\n              embedding,\n              usage,\n              rawResponse: modelResponse.rawResponse,\n            };\n          },\n        }),\n      );\n\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embedding': { output: () => JSON.stringify(embedding) },\n            'ai.usage.tokens': usage.tokens,\n          },\n        }),\n      );\n\n      return new DefaultEmbedResult({ value, embedding, usage, rawResponse });\n    },\n  });\n}\n\nclass DefaultEmbedResult<VALUE> implements EmbedResult<VALUE> {\n  readonly value: EmbedResult<VALUE>['value'];\n  readonly embedding: EmbedResult<VALUE>['embedding'];\n  readonly usage: EmbedResult<VALUE>['usage'];\n  readonly rawResponse: EmbedResult<VALUE>['rawResponse'];\n\n  constructor(options: {\n    value: EmbedResult<VALUE>['value'];\n    embedding: EmbedResult<VALUE>['embedding'];\n    usage: EmbedResult<VALUE>['usage'];\n    rawResponse?: EmbedResult<VALUE>['rawResponse'];\n  }) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.rawResponse = options.rawResponse;\n  }\n}\n","/**\n * Splits an array into chunks of a specified size.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to split.\n * @param {number} chunkSize - The size of each chunk.\n * @returns {T[][]} - A new array containing the chunks.\n */\nexport function splitArray<T>(array: T[], chunkSize: number): T[][] {\n  if (chunkSize <= 0) {\n    throw new Error('chunkSize must be greater than 0');\n  }\n\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n\n  return result;\n}\n","import { retryWithExponentialBackoff } from '../../util/retry-with-exponential-backoff';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { Embedding, EmbeddingModel } from '../types';\nimport { splitArray } from '../util/split-array';\nimport { EmbedManyResult } from './embed-many-result';\n\n/**\nEmbed several values using an embedding model. The type of the value is defined\nby the embedding model.\n\n`embedMany` automatically splits large requests into smaller chunks if the model\nhas a limit on how many embeddings can be generated in a single call.\n\n@param model - The embedding model to use.\n@param values - The values that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embeddings, the value, and additional information.\n */\nexport async function embedMany<VALUE>({\n  model,\n  values,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel<VALUE>;\n\n  /**\nThe values that should be embedded.\n   */\n  values: Array<VALUE>;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n}): Promise<EmbedManyResult<VALUE>> {\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embedMany',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embedMany', telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.values': {\n          input: () => values.map(value => JSON.stringify(value)),\n        },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n\n      // the model has not specified limits on\n      // how many embeddings can be generated in a single call\n      if (maxEmbeddingsPerCall == null) {\n        const { embeddings, usage } = await retry(() => {\n          // nested spans to align with the embedMany telemetry data:\n          return recordSpan({\n            name: 'ai.embedMany.doEmbed',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.embedMany.doEmbed',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.values': {\n                  input: () => values.map(value => JSON.stringify(value)),\n                },\n              },\n            }),\n            tracer,\n            fn: async doEmbedSpan => {\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers,\n              });\n\n              const embeddings = modelResponse.embeddings;\n              const usage = modelResponse.usage ?? { tokens: NaN };\n\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.embeddings': {\n                      output: () =>\n                        embeddings.map(embedding => JSON.stringify(embedding)),\n                    },\n                    'ai.usage.tokens': usage.tokens,\n                  },\n                }),\n              );\n\n              return { embeddings, usage };\n            },\n          });\n        });\n\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              'ai.embeddings': {\n                output: () =>\n                  embeddings.map(embedding => JSON.stringify(embedding)),\n              },\n              'ai.usage.tokens': usage.tokens,\n            },\n          }),\n        );\n\n        return new DefaultEmbedManyResult({ values, embeddings, usage });\n      }\n\n      // split the values into chunks that are small enough for the model:\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n\n      // serially embed the chunks:\n      const embeddings: Array<Embedding> = [];\n      let tokens = 0;\n\n      for (const chunk of valueChunks) {\n        const { embeddings: responseEmbeddings, usage } = await retry(() => {\n          // nested spans to align with the embedMany telemetry data:\n          return recordSpan({\n            name: 'ai.embedMany.doEmbed',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.embedMany.doEmbed',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.values': {\n                  input: () => chunk.map(value => JSON.stringify(value)),\n                },\n              },\n            }),\n            tracer,\n            fn: async doEmbedSpan => {\n              const modelResponse = await model.doEmbed({\n                values: chunk,\n                abortSignal,\n                headers,\n              });\n\n              const embeddings = modelResponse.embeddings;\n              const usage = modelResponse.usage ?? { tokens: NaN };\n\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.embeddings': {\n                      output: () =>\n                        embeddings.map(embedding => JSON.stringify(embedding)),\n                    },\n                    'ai.usage.tokens': usage.tokens,\n                  },\n                }),\n              );\n\n              return { embeddings, usage };\n            },\n          });\n        });\n\n        embeddings.push(...responseEmbeddings);\n        tokens += usage.tokens;\n      }\n\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embeddings': {\n              output: () =>\n                embeddings.map(embedding => JSON.stringify(embedding)),\n            },\n            'ai.usage.tokens': tokens,\n          },\n        }),\n      );\n\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n      });\n    },\n  });\n}\n\nclass DefaultEmbedManyResult<VALUE> implements EmbedManyResult<VALUE> {\n  readonly values: EmbedManyResult<VALUE>['values'];\n  readonly embeddings: EmbedManyResult<VALUE>['embeddings'];\n  readonly usage: EmbedManyResult<VALUE>['usage'];\n\n  constructor(options: {\n    values: EmbedManyResult<VALUE>['values'];\n    embeddings: EmbedManyResult<VALUE>['embeddings'];\n    usage: EmbedManyResult<VALUE>['usage'];\n  }) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n  }\n}\n","import { JSONValue } from '@ai-sdk/provider';\nimport { createIdGenerator, safeParseJSON } from '@ai-sdk/provider-utils';\nimport { Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { retryWithExponentialBackoff } from '../../util/retry-with-exponential-backoff';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { calculateLanguageModelUsage } from '../types/usage';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { GenerateObjectResult } from './generate-object-result';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { NoObjectGeneratedError } from './no-object-generated-error';\nimport { getOutputStrategy } from './output-strategy';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n     */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n     */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<OBJECT>>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@return\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<Array<ELEMENT>>>;\n/**\nGenerate a value from an enum (limited list of string values) using a language model.\n\nThis function does not stream the output.\n\n@return\nA result object that contains the generated value, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ENUM extends string>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'enum';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe enum values that the model should use.\n     */\n      enum: Array<ENUM>;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<ENUM>>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<JSONValue>>;\nexport async function generateObject<SCHEMA, RESULT>({\n  model,\n  enum: enumValues, // rename bc enum is reserved by typescript\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'enum' | 'no-schema';\n\n    model: LanguageModel;\n    enum?: Array<SCHEMA>;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_telemetry?: TelemetrySettings;\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateObjectResult<RESULT>> {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues,\n  });\n\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues,\n  });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateObject',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateObject',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.schema':\n          outputStrategy.jsonSchema != null\n            ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n            : undefined,\n        'ai.schema.name': schemaName,\n        'ai.schema.description': schemaDescription,\n        'ai.settings.output': outputStrategy.type,\n        'ai.settings.mode': mode,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n\n      // use the default provider mode when the mode is set to 'auto' or unspecified\n      if (mode === 'auto' || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n\n      let result: string;\n      let finishReason: FinishReason;\n      let usage: Parameters<typeof calculateLanguageModelUsage>[0];\n      let warnings: CallWarning[] | undefined;\n      let rawResponse: { headers?: Record<string, string> } | undefined;\n      let response: LanguageModelResponseMetadata;\n      let request: LanguageModelRequestMetadata;\n      let logprobs: LogProbs | undefined;\n      let resultProviderMetadata: ProviderMetadata | undefined;\n\n      switch (mode) {\n        case 'json': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: {\n              system:\n                outputStrategy.jsonSchema == null\n                  ? injectJsonInstruction({ prompt: system })\n                  : model.supportsStructuredOutputs\n                  ? system\n                  : injectJsonInstruction({\n                      prompt: system,\n                      schema: outputStrategy.jsonSchema,\n                    }),\n              prompt,\n              messages,\n            },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl,\n          });\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => standardizedPrompt.type,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => JSON.stringify(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-json',\n                    schema: outputStrategy.jsonSchema,\n                    name: schemaName,\n                    description: schemaDescription,\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat: standardizedPrompt.type,\n                  prompt: promptMessages,\n                  providerMetadata,\n                  abortSignal,\n                  headers,\n                });\n\n                if (result.text === undefined) {\n                  throw new NoObjectGeneratedError();\n                }\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => result.text },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // deprecated:\n                      'ai.finishReason': result.finishReason,\n                      'ai.result.object': { output: () => result.text },\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.prompt_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.completion_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText: result.text, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case 'tool': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: { system, prompt, messages },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl,\n          });\n          const inputFormat = standardizedPrompt.type;\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => inputFormat,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => JSON.stringify(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-tool',\n                    tool: {\n                      type: 'function',\n                      name: schemaName ?? 'json',\n                      description:\n                        schemaDescription ?? 'Respond with a JSON object.',\n                      parameters: outputStrategy.jsonSchema!,\n                    },\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  providerMetadata,\n                  abortSignal,\n                  headers,\n                });\n\n                const objectText = result.toolCalls?.[0]?.args;\n\n                if (objectText === undefined) {\n                  throw new NoObjectGeneratedError();\n                }\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => objectText },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // deprecated:\n                      'ai.finishReason': result.finishReason,\n                      'ai.result.object': { output: () => objectText },\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.output_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case undefined: {\n          throw new Error(\n            'Model does not have a default object generation mode.',\n          );\n        }\n\n        default: {\n          const _exhaustiveCheck: never = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n\n      const parseResult = safeParseJSON({ text: result });\n\n      if (!parseResult.success) {\n        throw parseResult.error;\n      }\n\n      const validationResult = outputStrategy.validateFinalResult(\n        parseResult.value,\n      );\n\n      if (!validationResult.success) {\n        throw validationResult.error;\n      }\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': finishReason,\n            'ai.response.object': {\n              output: () => JSON.stringify(validationResult.value),\n            },\n\n            'ai.usage.promptTokens': usage.promptTokens,\n            'ai.usage.completionTokens': usage.completionTokens,\n\n            // deprecated:\n            'ai.finishReason': finishReason,\n            'ai.result.object': {\n              output: () => JSON.stringify(validationResult.value),\n            },\n          },\n        }),\n      );\n\n      return new DefaultGenerateObjectResult({\n        object: validationResult.value,\n        finishReason,\n        usage: calculateLanguageModelUsage(usage),\n        warnings,\n        request,\n        response: {\n          ...response,\n          headers: rawResponse?.headers,\n        },\n        logprobs,\n        providerMetadata: resultProviderMetadata,\n      });\n    },\n  });\n}\n\nclass DefaultGenerateObjectResult<T> implements GenerateObjectResult<T> {\n  readonly object: GenerateObjectResult<T>['object'];\n  readonly finishReason: GenerateObjectResult<T>['finishReason'];\n  readonly usage: GenerateObjectResult<T>['usage'];\n  readonly warnings: GenerateObjectResult<T>['warnings'];\n  readonly rawResponse: GenerateObjectResult<T>['rawResponse'];\n  readonly logprobs: GenerateObjectResult<T>['logprobs'];\n  readonly experimental_providerMetadata: GenerateObjectResult<T>['experimental_providerMetadata'];\n  readonly response: GenerateObjectResult<T>['response'];\n  readonly request: GenerateObjectResult<T>['request'];\n\n  constructor(options: {\n    object: GenerateObjectResult<T>['object'];\n    finishReason: GenerateObjectResult<T>['finishReason'];\n    usage: GenerateObjectResult<T>['usage'];\n    warnings: GenerateObjectResult<T>['warnings'];\n    logprobs: GenerateObjectResult<T>['logprobs'];\n    providerMetadata: GenerateObjectResult<T>['experimental_providerMetadata'];\n    response: GenerateObjectResult<T>['response'];\n    request: GenerateObjectResult<T>['request'];\n  }) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    // deprecated:\n    this.rawResponse = {\n      headers: options.response.headers,\n    };\n    this.logprobs = options.logprobs;\n  }\n\n  toJsonResponse(init?: ResponseInit): Response {\n    return new Response(JSON.stringify(this.object), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: 'application/json; charset=utf-8',\n      }),\n    });\n  }\n}\n\n/**\n * @deprecated Use `generateObject` instead.\n */\nexport const experimental_generateObject = generateObject;\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_DownloadError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class DownloadError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly statusCode?: number;\n  readonly statusText?: string;\n\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null\n      ? `Failed to download ${url}: ${statusCode} ${statusText}`\n      : `Failed to download ${url}: ${cause}`,\n  }: {\n    url: string;\n    statusCode?: number;\n    statusText?: string;\n    message?: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n\n  static isInstance(error: unknown): error is DownloadError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isDownloadError(error: unknown): error is DownloadError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as DownloadError).url === 'string' &&\n      ((error as DownloadError).statusCode == null ||\n        typeof (error as DownloadError).statusCode === 'number') &&\n      ((error as DownloadError).statusText == null ||\n        typeof (error as DownloadError).statusText === 'string')\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      statusCode: this.statusCode,\n      statusText: this.statusText,\n      cause: this.cause,\n    };\n  }\n}\n","import { DownloadError } from './download-error';\n\nexport async function download({\n  url,\n  fetchImplementation = fetch,\n}: {\n  url: URL;\n  fetchImplementation?: typeof fetch;\n}): Promise<{\n  data: Uint8Array;\n  mimeType: string | undefined;\n}> {\n  const urlText = url.toString();\n  try {\n    const response = await fetchImplementation(urlText);\n\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText,\n      });\n    }\n\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mimeType: response.headers.get('content-type') ?? undefined,\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n","const mimeTypeSignatures = [\n  { mimeType: 'image/gif' as const, bytes: [0x47, 0x49, 0x46] },\n  { mimeType: 'image/png' as const, bytes: [0x89, 0x50, 0x4e, 0x47] },\n  { mimeType: 'image/jpeg' as const, bytes: [0xff, 0xd8] },\n  { mimeType: 'image/webp' as const, bytes: [0x52, 0x49, 0x46, 0x46] },\n];\n\nexport function detectImageMimeType(\n  image: Uint8Array,\n): 'image/jpeg' | 'image/png' | 'image/gif' | 'image/webp' | undefined {\n  for (const { bytes, mimeType } of mimeTypeSignatures) {\n    if (\n      image.length >= bytes.length &&\n      bytes.every((byte, index) => image[index] === byte)\n    ) {\n      return mimeType;\n    }\n  }\n\n  return undefined;\n}\n","import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\nimport { InvalidDataContentError } from './invalid-data-content-error';\nimport { z } from 'zod';\n\n/**\nData content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.\n */\nexport type DataContent = string | Uint8Array | ArrayBuffer | Buffer;\n\n/**\n@internal\n */\nexport const dataContentSchema: z.ZodType<DataContent> = z.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value: unknown): value is Buffer =>\n      globalThis.Buffer?.isBuffer(value) ?? false,\n    { message: 'Must be a Buffer' },\n  ),\n]);\n\n/**\nConverts data content to a base64-encoded string.\n\n@param content - Data content to convert.\n@returns Base64-encoded string.\n*/\nexport function convertDataContentToBase64String(content: DataContent): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n\n  return convertUint8ArrayToBase64(content);\n}\n\n/**\nConverts data content to a Uint8Array.\n\n@param content - Data content to convert.\n@returns Uint8Array.\n */\nexport function convertDataContentToUint8Array(\n  content: DataContent,\n): Uint8Array {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n\n  if (typeof content === 'string') {\n    try {\n      return convertBase64ToUint8Array(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message:\n          'Invalid data content. Content string is not a base64-encoded media.',\n        content,\n        cause: error,\n      });\n    }\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n\n  throw new InvalidDataContentError({ content });\n}\n\n/**\n * Converts a Uint8Array to a string of text.\n *\n * @param uint8Array - The Uint8Array to convert.\n * @returns The converted string.\n */\nexport function convertUint8ArrayToText(uint8Array: Uint8Array): string {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error('Error decoding Uint8Array to text');\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidDataContentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidDataContentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly content: unknown;\n\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`,\n  }: {\n    content: unknown;\n    cause?: unknown;\n    message?: string;\n  }) {\n    super({ name, message, cause });\n\n    this.content = content;\n  }\n\n  static isInstance(error: unknown): error is InvalidDataContentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidDataContentError(\n    error: unknown,\n  ): error is InvalidDataContentError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      (error as InvalidDataContentError).content != null\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      cause: this.cause,\n      content: this.content,\n    };\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidMessageRoleError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidMessageRoleError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly role: string;\n\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`,\n  }: {\n    role: string;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.role = role;\n  }\n\n  static isInstance(error: unknown): error is InvalidMessageRoleError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidMessageRoleError(\n    error: unknown,\n  ): error is InvalidMessageRoleError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as InvalidMessageRoleError).role === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      role: this.role,\n    };\n  }\n}\n","export function splitDataUrl(dataUrl: string): {\n  mimeType: string | undefined;\n  base64Content: string | undefined;\n} {\n  try {\n    const [header, base64Content] = dataUrl.split(',');\n    return {\n      mimeType: header.split(';')[0].split(':')[1],\n      base64Content,\n    };\n  } catch (error) {\n    return {\n      mimeType: undefined,\n      base64Content: undefined,\n    };\n  }\n}\n","import {\n  LanguageModelV1FilePart,\n  LanguageModelV1ImagePart,\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  LanguageModelV1TextPart,\n} from '@ai-sdk/provider';\nimport { download } from '../../util/download';\nimport { CoreMessage } from '../prompt/message';\nimport { detectImageMimeType } from '../util/detect-image-mimetype';\nimport { FilePart, ImagePart, TextPart } from './content-part';\nimport {\n  convertDataContentToBase64String,\n  convertDataContentToUint8Array,\n  DataContent,\n} from './data-content';\nimport { InvalidMessageRoleError } from './invalid-message-role-error';\nimport { splitDataUrl } from './split-data-url';\nimport { StandardizedPrompt } from './standardize-prompt';\n\nexport async function convertToLanguageModelPrompt({\n  prompt,\n  modelSupportsImageUrls = true,\n  modelSupportsUrl = () => false,\n  downloadImplementation = download,\n}: {\n  prompt: StandardizedPrompt;\n  modelSupportsImageUrls: boolean | undefined;\n  modelSupportsUrl: undefined | ((url: URL) => boolean);\n  downloadImplementation?: typeof download;\n}): Promise<LanguageModelV1Prompt> {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    downloadImplementation,\n    modelSupportsImageUrls,\n    modelSupportsUrl,\n  );\n\n  return [\n    ...(prompt.system != null\n      ? [{ role: 'system' as const, content: prompt.system }]\n      : []),\n    ...prompt.messages.map(message =>\n      convertToLanguageModelMessage(message, downloadedAssets),\n    ),\n  ];\n}\n\n/**\n * Convert a CoreMessage to a LanguageModelV1Message.\n *\n * @param message The CoreMessage to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *   available if the model does not support URLs, null otherwise.\n */\nexport function convertToLanguageModelMessage(\n  message: CoreMessage,\n  downloadedAssets: Record<\n    string,\n    { mimeType: string | undefined; data: Uint8Array }\n  >,\n): LanguageModelV1Message {\n  const role = message.role;\n  switch (role) {\n    case 'system': {\n      return {\n        role: 'system',\n        content: message.content,\n        providerMetadata: message.experimental_providerMetadata,\n      };\n    }\n\n    case 'user': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'user',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata: message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'user',\n        content: message.content\n          .map(part => convertPartToLanguageModelPart(part, downloadedAssets))\n          // remove empty text parts:\n          .filter(part => part.type !== 'text' || part.text !== ''),\n        providerMetadata: message.experimental_providerMetadata,\n      };\n    }\n\n    case 'assistant': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'assistant',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata: message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'assistant',\n        content: message.content\n          .filter(\n            // remove empty text parts:\n            part => part.type !== 'text' || part.text !== '',\n          )\n          .map(part => {\n            const { experimental_providerMetadata, ...rest } = part;\n            return {\n              ...rest,\n              providerMetadata: experimental_providerMetadata,\n            };\n          }),\n        providerMetadata: message.experimental_providerMetadata,\n      };\n    }\n\n    case 'tool': {\n      return {\n        role: 'tool',\n        content: message.content.map(part => ({\n          type: 'tool-result',\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.result,\n          content: part.experimental_content,\n          isError: part.isError,\n          providerMetadata: part.experimental_providerMetadata,\n        })),\n        providerMetadata: message.experimental_providerMetadata,\n      };\n    }\n\n    default: {\n      const _exhaustiveCheck: never = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\n\n/**\n * Downloads images and files from URLs in the messages.\n */\nasync function downloadAssets(\n  messages: CoreMessage[],\n  downloadImplementation: typeof download,\n  modelSupportsImageUrls: boolean | undefined,\n  modelSupportsUrl: (url: URL) => boolean,\n): Promise<Record<string, { mimeType: string | undefined; data: Uint8Array }>> {\n  const urls = messages\n    .filter(message => message.role === 'user')\n    .map(message => message.content)\n    .filter((content): content is Array<TextPart | ImagePart | FilePart> =>\n      Array.isArray(content),\n    )\n    .flat()\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        part.type === 'image' || part.type === 'file',\n    )\n    /**\n     * Filter out image parts if the model supports image URLs, before letting it\n     * decide if it supports a particular URL.\n     */\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        !(part.type === 'image' && modelSupportsImageUrls === true),\n    )\n    .map(part => (part.type === 'image' ? part.image : part.data))\n    .map(part =>\n      // support string urls:\n      typeof part === 'string' &&\n      (part.startsWith('http:') || part.startsWith('https:'))\n        ? new URL(part)\n        : part,\n    )\n    .filter((image): image is URL => image instanceof URL)\n    /**\n     * Filter out URLs that the model supports natively, so we don't download them.\n     */\n    .filter(url => !modelSupportsUrl(url));\n\n  // download in parallel:\n  const downloadedImages = await Promise.all(\n    urls.map(async url => ({\n      url,\n      data: await downloadImplementation({ url }),\n    })),\n  );\n\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data]),\n  );\n}\n\n/**\n * Convert part of a message to a LanguageModelV1Part.\n * @param part The part to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *  available if the model does not support URLs, null otherwise.\n *\n * @returns The converted part.\n */\nfunction convertPartToLanguageModelPart(\n  part: TextPart | ImagePart | FilePart,\n  downloadedAssets: Record<\n    string,\n    { mimeType: string | undefined; data: Uint8Array }\n  >,\n):\n  | LanguageModelV1TextPart\n  | LanguageModelV1ImagePart\n  | LanguageModelV1FilePart {\n  if (part.type === 'text') {\n    return {\n      type: 'text',\n      text: part.text,\n      providerMetadata: part.experimental_providerMetadata,\n    };\n  }\n\n  let mimeType: string | undefined = part.mimeType;\n  let data: DataContent | URL;\n  let content: URL | ArrayBuffer | string;\n  let normalizedData: Uint8Array | URL;\n\n  const type = part.type;\n  switch (type) {\n    case 'image':\n      data = part.image;\n      break;\n    case 'file':\n      data = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n\n  // Attempt to create a URL from the data. If it fails, we can assume the data\n  // is not a URL and likely some other sort of data.\n  try {\n    content = typeof data === 'string' ? new URL(data) : data;\n  } catch (error) {\n    content = data;\n  }\n\n  // If we successfully created a URL, we can use that to normalize the data\n  // either by passing it through or converting normalizing the base64 content\n  // to a Uint8Array.\n  if (content instanceof URL) {\n    // If the content is a data URL, we want to convert that to a Uint8Array\n    if (content.protocol === 'data:') {\n      const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(\n        content.toString(),\n      );\n\n      if (dataUrlMimeType == null || base64Content == null) {\n        throw new Error(`Invalid data URL format in part ${type}`);\n      }\n\n      mimeType = dataUrlMimeType;\n      normalizedData = convertDataContentToUint8Array(base64Content);\n    } else {\n      /**\n       * If the content is a URL, we should first see if it was downloaded. And if not,\n       * we can let the model decide if it wants to support the URL. This also allows\n       * for non-HTTP URLs to be passed through (e.g. gs://).\n       */\n      const downloadedFile = downloadedAssets[content.toString()];\n      if (downloadedFile) {\n        normalizedData = downloadedFile.data;\n        mimeType ??= downloadedFile.mimeType;\n      } else {\n        normalizedData = content;\n      }\n    }\n  } else {\n    // Since we know know the content is not a URL, we can attempt to normalize the data\n    // assuming it is some sort of data.\n    normalizedData = convertDataContentToUint8Array(content);\n  }\n\n  // Now that we have the normalized data either as a URL or a Uint8Array,\n  // we can create the LanguageModelV1Part.\n  switch (type) {\n    case 'image':\n      // We give a best effort to detect the mime type if it is not provided.\n      // otherwise, we use the provided mime type.\n      if (mimeType == null && normalizedData instanceof Uint8Array) {\n        mimeType = detectImageMimeType(normalizedData);\n      }\n\n      return {\n        type: 'image',\n        image: normalizedData,\n        mimeType,\n        providerMetadata: part.experimental_providerMetadata,\n      };\n    case 'file':\n      // We should have a mimeType at this point, if not, throw an error.\n      if (mimeType == null) {\n        throw new Error(`Mime type is missing for file part`);\n      }\n\n      return {\n        type: 'file',\n        data:\n          normalizedData instanceof Uint8Array\n            ? convertDataContentToBase64String(normalizedData)\n            : normalizedData,\n        mimeType,\n        providerMetadata: part.experimental_providerMetadata,\n      };\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly parameter: string;\n  readonly value: unknown;\n\n  constructor({\n    parameter,\n    value,\n    message,\n  }: {\n    parameter: string;\n    value: unknown;\n    message: string;\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`,\n    });\n\n    this.parameter = parameter;\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidArgumentError(error: unknown): error is InvalidArgumentError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as InvalidArgumentError).parameter === 'string' &&\n      typeof (error as InvalidArgumentError).value === 'string'\n    );\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      parameter: this.parameter,\n      value: this.value,\n    };\n  }\n}\n","import { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { CallSettings } from './call-settings';\n\n/**\n * Validates call settings and sets default values.\n */\nexport function prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  stopSequences,\n  seed,\n  maxRetries,\n}: Omit<CallSettings, 'abortSignal' | 'headers'>): Omit<\n  CallSettings,\n  'abortSignal' | 'headers'\n> {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be an integer',\n      });\n    }\n\n    if (maxTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be >= 1',\n      });\n    }\n  }\n\n  if (temperature != null) {\n    if (typeof temperature !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'temperature',\n        value: temperature,\n        message: 'temperature must be a number',\n      });\n    }\n  }\n\n  if (topP != null) {\n    if (typeof topP !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topP',\n        value: topP,\n        message: 'topP must be a number',\n      });\n    }\n  }\n\n  if (topK != null) {\n    if (typeof topK !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topK',\n        value: topK,\n        message: 'topK must be a number',\n      });\n    }\n  }\n\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'presencePenalty',\n        value: presencePenalty,\n        message: 'presencePenalty must be a number',\n      });\n    }\n  }\n\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'frequencyPenalty',\n        value: frequencyPenalty,\n        message: 'frequencyPenalty must be a number',\n      });\n    }\n  }\n\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: 'seed',\n        value: seed,\n        message: 'seed must be an integer',\n      });\n    }\n  }\n\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be an integer',\n      });\n    }\n\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be >= 0',\n      });\n    }\n  }\n\n  return {\n    maxTokens,\n    temperature: temperature ?? 0,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences:\n      stopSequences != null && stopSequences.length > 0\n        ? stopSequences\n        : undefined,\n    seed,\n    maxRetries: maxRetries ?? 2,\n  };\n}\n","import { InvalidPromptError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { CoreMessage, coreMessageSchema } from './message';\nimport { Prompt } from './prompt';\nimport { detectPromptType } from './detect-prompt-type';\nimport { convertToCoreMessages } from './convert-to-core-messages';\nimport { UIMessage } from './ui-message';\nimport { CoreTool } from '../tool/tool';\n\nexport type StandardizedPrompt = {\n  /**\n   * Original prompt type. This is forwarded to the providers and can be used\n   * to write send raw text to providers that support it.\n   */\n  type: 'prompt' | 'messages';\n\n  /**\n   * System message.\n   */\n  system?: string;\n\n  /**\n   * Messages.\n   */\n  messages: CoreMessage[];\n};\n\nexport function standardizePrompt<TOOLS extends Record<string, CoreTool>>({\n  prompt,\n  tools,\n}: {\n  prompt: Prompt;\n  tools: undefined | TOOLS;\n}): StandardizedPrompt {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt or messages must be defined',\n    });\n  }\n\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt and messages cannot be defined at the same time',\n    });\n  }\n\n  // validate that system is a string\n  if (prompt.system != null && typeof prompt.system !== 'string') {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'system must be a string',\n    });\n  }\n\n  // type: prompt\n  if (prompt.prompt != null) {\n    // validate that prompt is a string\n    if (typeof prompt.prompt !== 'string') {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'prompt must be a string',\n      });\n    }\n\n    return {\n      type: 'prompt',\n      system: prompt.system,\n      messages: [\n        {\n          role: 'user',\n          content: prompt.prompt,\n        },\n      ],\n    };\n  }\n\n  // type: messages\n  if (prompt.messages != null) {\n    const promptType = detectPromptType(prompt.messages);\n\n    if (promptType === 'other') {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'messages must be an array of CoreMessage or UIMessage',\n      });\n    }\n\n    const messages: CoreMessage[] =\n      promptType === 'ui-messages'\n        ? convertToCoreMessages(prompt.messages as UIMessage[], {\n            tools,\n          })\n        : (prompt.messages as CoreMessage[]);\n\n    const validationResult = safeValidateTypes({\n      value: messages,\n      schema: z.array(coreMessageSchema),\n    });\n\n    if (!validationResult.success) {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'messages must be an array of CoreMessage or UIMessage',\n        cause: validationResult.error,\n      });\n    }\n\n    return {\n      type: 'messages',\n      messages,\n      system: prompt.system,\n    };\n  }\n\n  throw new Error('unreachable');\n}\n","import { z } from 'zod';\nimport { ProviderMetadata } from '../types';\nimport { providerMetadataSchema } from '../types/provider-metadata';\nimport {\n  FilePart,\n  filePartSchema,\n  ImagePart,\n  imagePartSchema,\n  TextPart,\n  textPartSchema,\n  ToolCallPart,\n  toolCallPartSchema,\n  ToolResultPart,\n  toolResultPartSchema,\n} from './content-part';\n\n/**\n A system message. It can contain system information.\n\n Note: using the \"system\" part of the prompt is strongly preferred\n to increase the resilience against prompt injection attacks,\n and because not all providers support several system messages.\n */\nexport type CoreSystemMessage = {\n  role: 'system';\n  content: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreSystemMessageSchema: z.ZodType<CoreSystemMessage> = z.object({\n  role: z.literal('system'),\n  content: z.string(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\n * @deprecated Use `CoreMessage` instead.\n */\nexport type ExperimentalMessage = CoreMessage;\n\n/**\nA user message. It can contain text or a combination of text and images.\n */\nexport type CoreUserMessage = {\n  role: 'user';\n  content: UserContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreUserMessageSchema: z.ZodType<CoreUserMessage> = z.object({\n  role: z.literal('user'),\n  content: z.union([\n    z.string(),\n    z.array(z.union([textPartSchema, imagePartSchema, filePartSchema])),\n  ]),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\n * @deprecated Use `CoreUserMessage` instead.\n */\nexport type ExperimentalUserMessage = CoreUserMessage;\n\n/**\nContent of a user message. It can be a string or an array of text and image parts.\n */\nexport type UserContent = string | Array<TextPart | ImagePart | FilePart>;\n\n/**\nAn assistant message. It can contain text, tool calls, or a combination of text and tool calls.\n */\nexport type CoreAssistantMessage = {\n  role: 'assistant';\n  content: AssistantContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreAssistantMessageSchema: z.ZodType<CoreAssistantMessage> =\n  z.object({\n    role: z.literal('assistant'),\n    content: z.union([\n      z.string(),\n      z.array(z.union([textPartSchema, toolCallPartSchema])),\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\n * @deprecated Use `CoreAssistantMessage` instead.\n */\nexport type ExperimentalAssistantMessage = CoreAssistantMessage;\n\n/**\nContent of an assistant message. It can be a string or an array of text and tool call parts.\n */\nexport type AssistantContent = string | Array<TextPart | ToolCallPart>;\n\n/**\nA tool message. It contains the result of one or more tool calls.\n */\nexport type CoreToolMessage = {\n  role: 'tool';\n  content: ToolContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreToolMessageSchema: z.ZodType<CoreToolMessage> = z.object({\n  role: z.literal('tool'),\n  content: z.array(toolResultPartSchema),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\n * @deprecated Use `CoreToolMessage` instead.\n */\nexport type ExperimentalToolMessage = CoreToolMessage;\n\n/**\nContent of a tool message. It is an array of tool result parts.\n */\nexport type ToolContent = Array<ToolResultPart>;\n\n/**\nA message that can be used in the `messages` field of a prompt.\nIt can be a user message, an assistant message, or a tool message.\n */\nexport type CoreMessage =\n  | CoreSystemMessage\n  | CoreUserMessage\n  | CoreAssistantMessage\n  | CoreToolMessage;\n\nexport const coreMessageSchema: z.ZodType<CoreMessage> = z.union([\n  coreSystemMessageSchema,\n  coreUserMessageSchema,\n  coreAssistantMessageSchema,\n  coreToolMessageSchema,\n]);\n","import { LanguageModelV1ProviderMetadata } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { jsonValueSchema } from './json-value';\n\n/**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\nexport type ProviderMetadata = LanguageModelV1ProviderMetadata;\n\nexport const providerMetadataSchema: z.ZodType<ProviderMetadata> = z.record(\n  z.string(),\n  z.record(z.string(), jsonValueSchema),\n);\n","import { JSONValue } from '@ai-sdk/provider';\nimport { z } from 'zod';\n\nexport const jsonValueSchema: z.ZodType<JSONValue> = z.lazy(() =>\n  z.union([\n    z.null(),\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.record(z.string(), jsonValueSchema),\n    z.array(jsonValueSchema),\n  ]),\n);\n","import { z } from 'zod';\nimport {\n  ProviderMetadata,\n  providerMetadataSchema,\n} from '../types/provider-metadata';\nimport { DataContent, dataContentSchema } from './data-content';\nimport {\n  ToolResultContent,\n  toolResultContentSchema,\n} from './tool-result-content';\n\n/**\nText content part of a prompt. It contains a string of text.\n */\nexport interface TextPart {\n  type: 'text';\n\n  /**\nThe text content.\n   */\n  text: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\nexport const textPartSchema: z.ZodType<TextPart> = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nImage content part of a prompt. It contains an image.\n */\nexport interface ImagePart {\n  type: 'image';\n\n  /**\nImage data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  image: DataContent | URL;\n\n  /**\nOptional mime type of the image.\n   */\n  mimeType?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\nexport const imagePartSchema: z.ZodType<ImagePart> = z.object({\n  type: z.literal('image'),\n  image: z.union([dataContentSchema, z.instanceof(URL)]),\n  mimeType: z.string().optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nFile content part of a prompt. It contains a file.\n */\nexport interface FilePart {\n  type: 'file';\n\n  /**\nFile data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  data: DataContent | URL;\n\n  /**\nMime type of the file.\n   */\n  mimeType: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\nexport const filePartSchema: z.ZodType<FilePart> = z.object({\n  type: z.literal('file'),\n  data: z.union([dataContentSchema, z.instanceof(URL)]),\n  mimeType: z.string(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nTool call content part of a prompt. It contains a tool call (usually generated by the AI model).\n */\nexport interface ToolCallPart {\n  type: 'tool-call';\n\n  /**\nID of the tool call. This ID is used to match the tool call with the tool result.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that is being called.\n */\n  toolName: string;\n\n  /**\nArguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.\n   */\n  args: unknown;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\nexport const toolCallPartSchema: z.ZodType<ToolCallPart> = z.object({\n  type: z.literal('tool-call'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  args: z.unknown(),\n}) as z.ZodType<ToolCallPart>; // necessary bc args is optional on Zod type\n\n/**\nTool result content part of a prompt. It contains the result of the tool call with the matching ID.\n */\nexport interface ToolResultPart {\n  type: 'tool-result';\n\n  /**\nID of the tool call that this result is associated with.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that generated this result.\n  */\n  toolName: string;\n\n  /**\nResult of the tool call. This is a JSON-serializable object.\n   */\n  result: unknown;\n\n  /**\nMulti-part content of the tool result. Only for tools that support multipart results.\n   */\n  experimental_content?: ToolResultContent;\n\n  /**\nOptional flag if the result is an error or an error message.\n   */\n  isError?: boolean;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\nexport const toolResultPartSchema: z.ZodType<ToolResultPart> = z.object({\n  type: z.literal('tool-result'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  result: z.unknown(),\n  content: toolResultContentSchema.optional(),\n  isError: z.boolean().optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolResultPart>; // necessary bc result is optional on Zod type\n","import { z } from 'zod';\n\nexport type ToolResultContent = Array<\n  | {\n      type: 'text';\n      text: string;\n    }\n  | {\n      type: 'image';\n      data: string; // base64 encoded png image, e.g. screenshot\n      mimeType?: string; // e.g. 'image/png';\n    }\n>;\n\nexport const toolResultContentSchema: z.ZodType<ToolResultContent> = z.array(\n  z.union([\n    z.object({ type: z.literal('text'), text: z.string() }),\n    z.object({\n      type: z.literal('image'),\n      data: z.string(),\n      mimeType: z.string().optional(),\n    }),\n  ]),\n);\n\nexport function isToolResultContent(\n  value: unknown,\n): value is ToolResultContent {\n  if (!Array.isArray(value) || value.length === 0) {\n    return false;\n  }\n\n  return value.every(part => {\n    if (typeof part !== 'object' || part === null) {\n      return false;\n    }\n\n    if (part.type === 'text') {\n      return typeof part.text === 'string';\n    }\n\n    if (part.type === 'image') {\n      return (\n        typeof part.data === 'string' &&\n        (part.mimeType === undefined || typeof part.mimeType === 'string')\n      );\n    }\n\n    return false;\n  });\n}\n","export function detectPromptType(\n  prompt: Array<any>,\n): 'ui-messages' | 'messages' | 'other' {\n  if (!Array.isArray(prompt)) {\n    return 'other';\n  }\n\n  if (prompt.length === 0) {\n    return 'messages';\n  }\n\n  const characteristics = prompt.map(detectSingleMessageCharacteristics);\n\n  if (characteristics.some(c => c === 'has-ui-specific-parts')) {\n    return 'ui-messages';\n  } else if (\n    characteristics.every(\n      c => c === 'has-core-specific-parts' || c === 'message',\n    )\n  ) {\n    return 'messages';\n  } else {\n    return 'other';\n  }\n}\n\nfunction detectSingleMessageCharacteristics(\n  message: any,\n): 'has-ui-specific-parts' | 'has-core-specific-parts' | 'message' | 'other' {\n  if (\n    typeof message === 'object' &&\n    message !== null &&\n    (message.role === 'function' || // UI-only role\n      message.role === 'data' || // UI-only role\n      'toolInvocations' in message || // UI-specific field\n      'experimental_attachments' in message)\n  ) {\n    return 'has-ui-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'content' in message &&\n    (Array.isArray(message.content) || // Core messages can have array content\n      'experimental_providerMetadata' in message)\n  ) {\n    return 'has-core-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'role' in message &&\n    'content' in message &&\n    typeof message.content === 'string' &&\n    ['system', 'user', 'assistant', 'tool'].includes(message.role)\n  ) {\n    return 'message';\n  } else {\n    return 'other';\n  }\n}\n","import { Attachment } from '@ai-sdk/ui-utils';\nimport { FilePart, ImagePart, TextPart } from './content-part';\nimport {\n  convertDataContentToUint8Array,\n  convertUint8ArrayToText,\n} from './data-content';\n\ntype ContentPart = TextPart | ImagePart | FilePart;\n\n/**\n * Converts a list of attachments to a list of content parts\n * for consumption by `ai/core` functions.\n * Currently only supports images and text attachments.\n */\nexport function attachmentsToParts(attachments: Attachment[]): ContentPart[] {\n  const parts: ContentPart[] = [];\n\n  for (const attachment of attachments) {\n    let url;\n\n    try {\n      url = new URL(attachment.url);\n    } catch (error) {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n\n    switch (url.protocol) {\n      case 'http:':\n      case 'https:': {\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({ type: 'image', image: url });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              'If the attachment is not an image, it must specify a content type',\n            );\n          }\n\n          parts.push({\n            type: 'file',\n            data: url,\n            mimeType: attachment.contentType,\n          });\n        }\n        break;\n      }\n\n      case 'data:': {\n        let header;\n        let base64Content;\n        let mimeType;\n\n        try {\n          [header, base64Content] = attachment.url.split(',');\n          mimeType = header.split(';')[0].split(':')[1];\n        } catch (error) {\n          throw new Error(`Error processing data URL: ${attachment.url}`);\n        }\n\n        if (mimeType == null || base64Content == null) {\n          throw new Error(`Invalid data URL format: ${attachment.url}`);\n        }\n\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({\n            type: 'image',\n            image: convertDataContentToUint8Array(base64Content),\n          });\n        } else if (attachment.contentType?.startsWith('text/')) {\n          parts.push({\n            type: 'text',\n            text: convertUint8ArrayToText(\n              convertDataContentToUint8Array(base64Content),\n            ),\n          });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              'If the attachment is not an image or text, it must specify a content type',\n            );\n          }\n\n          parts.push({\n            type: 'file',\n            data: base64Content,\n            mimeType: attachment.contentType,\n          });\n        }\n\n        break;\n      }\n\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n\n  return parts;\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { UIMessage } from './ui-message';\n\nconst name = 'AI_MessageConversionError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class MessageConversionError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly originalMessage: UIMessage;\n\n  constructor({\n    originalMessage,\n    message,\n  }: {\n    originalMessage: UIMessage;\n    message: string;\n  }) {\n    super({ name, message });\n\n    this.originalMessage = originalMessage;\n  }\n\n  static isInstance(error: unknown): error is MessageConversionError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { CoreMessage, ToolCallPart, ToolResultPart } from '../prompt';\nimport { CoreTool } from '../tool/tool';\nimport { attachmentsToParts } from './attachments-to-parts';\nimport { MessageConversionError } from './message-conversion-error';\nimport { UIMessage } from './ui-message';\n\n/**\nConverts an array of messages from useChat into an array of CoreMessages that can be used\nwith the AI core functions (e.g. `streamText`).\n */\nexport function convertToCoreMessages<\n  TOOLS extends Record<string, CoreTool> = never,\n>(messages: Array<UIMessage>, options?: { tools?: TOOLS }) {\n  const tools = options?.tools ?? ({} as TOOLS);\n  const coreMessages: CoreMessage[] = [];\n\n  for (const message of messages) {\n    const { role, content, toolInvocations, experimental_attachments } =\n      message;\n\n    switch (role) {\n      case 'system': {\n        coreMessages.push({\n          role: 'system',\n          content,\n        });\n        break;\n      }\n\n      case 'user': {\n        coreMessages.push({\n          role: 'user',\n          content: experimental_attachments\n            ? [\n                { type: 'text', text: content },\n                ...attachmentsToParts(experimental_attachments),\n              ]\n            : content,\n        });\n        break;\n      }\n\n      case 'assistant': {\n        if (toolInvocations == null) {\n          coreMessages.push({ role: 'assistant', content });\n          break;\n        }\n\n        // assistant message with tool calls\n        coreMessages.push({\n          role: 'assistant',\n          content: [\n            { type: 'text', text: content },\n            ...toolInvocations.map(\n              ({ toolCallId, toolName, args }): ToolCallPart => ({\n                type: 'tool-call' as const,\n                toolCallId,\n                toolName,\n                args,\n              }),\n            ),\n          ],\n        });\n\n        // tool message with tool results\n        coreMessages.push({\n          role: 'tool',\n          content: toolInvocations.map((toolInvocation): ToolResultPart => {\n            if (!('result' in toolInvocation)) {\n              throw new MessageConversionError({\n                originalMessage: message,\n                message:\n                  'ToolInvocation must have a result: ' +\n                  JSON.stringify(toolInvocation),\n              });\n            }\n\n            const { toolCallId, toolName, result } = toolInvocation;\n\n            const tool = tools[toolName];\n            return tool?.experimental_toToolResultContent != null\n              ? {\n                  type: 'tool-result',\n                  toolCallId,\n                  toolName,\n                  result: tool.experimental_toToolResultContent(result),\n                  experimental_content:\n                    tool.experimental_toToolResultContent(result),\n                }\n              : {\n                  type: 'tool-result',\n                  toolCallId,\n                  toolName,\n                  result,\n                };\n          }),\n        });\n\n        break;\n      }\n\n      case 'function':\n      case 'data':\n      case 'tool': {\n        // ignore\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`,\n        });\n      }\n    }\n  }\n\n  return coreMessages;\n}\n","/**\nRepresents the number of tokens used in a prompt and completion.\n */\nexport type LanguageModelUsage = {\n  /**\nThe number of tokens used in the prompt.\n   */\n  promptTokens: number;\n\n  /**\nThe number of tokens used in the completion.\n */\n  completionTokens: number;\n\n  /**\nThe total number of tokens used (promptTokens + completionTokens).\n   */\n  totalTokens: number;\n};\n\n/**\nRepresents the number of tokens used in a prompt and completion.\n\n@deprecated Use `LanguageModelUsage` instead.\n */\nexport type CompletionTokenUsage = LanguageModelUsage;\n\n/**\nRepresents the number of tokens used in an embedding.\n */\nexport type EmbeddingModelUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n\n@deprecated Use `EmbeddingModelUsage` instead.\n */\nexport type EmbeddingTokenUsage = EmbeddingModelUsage;\n\nexport function calculateLanguageModelUsage(usage: {\n  promptTokens: number;\n  completionTokens: number;\n}): LanguageModelUsage {\n  return {\n    promptTokens: usage.promptTokens,\n    completionTokens: usage.completionTokens,\n    totalTokens: usage.promptTokens + usage.completionTokens,\n  };\n}\n","export function prepareResponseHeaders(\n  init: ResponseInit | undefined,\n  {\n    contentType,\n    dataStreamVersion,\n  }: { contentType: string; dataStreamVersion?: 'v1' | undefined },\n) {\n  const headers = new Headers(init?.headers ?? {});\n\n  if (!headers.has('Content-Type')) {\n    headers.set('Content-Type', contentType);\n  }\n\n  if (dataStreamVersion !== undefined) {\n    headers.set('X-Vercel-AI-Data-Stream', dataStreamVersion);\n  }\n\n  return headers;\n}\n","import { JSONSchema7 } from 'json-schema';\n\nconst DEFAULT_SCHEMA_PREFIX = 'JSON schema:';\nconst DEFAULT_SCHEMA_SUFFIX =\n  'You MUST answer with a JSON object that matches the JSON schema above.';\nconst DEFAULT_GENERIC_SUFFIX = 'You MUST answer with JSON.';\n\nexport function injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : undefined,\n  schemaSuffix = schema != null\n    ? DEFAULT_SCHEMA_SUFFIX\n    : DEFAULT_GENERIC_SUFFIX,\n}: {\n  prompt?: string;\n  schema?: JSONSchema7;\n  schemaPrefix?: string;\n  schemaSuffix?: string;\n}): string {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : undefined,\n    prompt != null && prompt.length > 0 ? '' : undefined, // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : undefined,\n    schemaSuffix,\n  ]\n    .filter(line => line != null)\n    .join('\\n');\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoObjectGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate a parsable object.\n */\nexport class NoObjectGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'No object generated.' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoObjectGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoObjectGeneratedError(\n    error: unknown,\n  ): error is NoObjectGeneratedError {\n    return error instanceof Error && error.name === name;\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack,\n    };\n  }\n}\n","import {\n  isJSONArray,\n  isJSONObject,\n  JSONObject,\n  JSONValue,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { safeValidateTypes, ValidationResult } from '@ai-sdk/provider-utils';\nimport { asSchema, DeepPartial, Schema } from '@ai-sdk/ui-utils';\nimport { NoObjectGeneratedError } from './no-object-generated-error';\nimport { JSONSchema7 } from 'json-schema';\nimport { ObjectStreamPart } from './stream-object-result';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { z } from 'zod';\n\nexport interface OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM> {\n  readonly type: 'object' | 'array' | 'enum' | 'no-schema';\n  readonly jsonSchema: JSONSchema7 | undefined;\n\n  validatePartialResult({\n    value,\n    textDelta,\n    isFinalDelta,\n  }: {\n    value: JSONValue;\n    textDelta: string;\n    isFirstDelta: boolean;\n    isFinalDelta: boolean;\n    latestObject: PARTIAL | undefined;\n  }): ValidationResult<{\n    partial: PARTIAL;\n    textDelta: string;\n  }>;\n  validateFinalResult(value: JSONValue | undefined): ValidationResult<RESULT>;\n\n  createElementStream(\n    originalStream: ReadableStream<ObjectStreamPart<PARTIAL>>,\n  ): ELEMENT_STREAM;\n}\n\nconst noSchemaOutputStrategy: OutputStrategy<JSONValue, JSONValue, never> = {\n  type: 'no-schema',\n  jsonSchema: undefined,\n\n  validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n\n  validateFinalResult(\n    value: JSONValue | undefined,\n  ): ValidationResult<JSONValue> {\n    return value === undefined\n      ? { success: false, error: new NoObjectGeneratedError() }\n      : { success: true, value };\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in no-schema mode',\n    });\n  },\n};\n\nconst objectOutputStrategy = <OBJECT>(\n  schema: Schema<OBJECT>,\n): OutputStrategy<DeepPartial<OBJECT>, OBJECT, never> => ({\n  type: 'object',\n  jsonSchema: schema.jsonSchema,\n\n  validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value as DeepPartial<OBJECT>,\n        textDelta,\n      },\n    };\n  },\n\n  validateFinalResult(value: JSONValue | undefined): ValidationResult<OBJECT> {\n    return safeValidateTypes({ value, schema });\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in object mode',\n    });\n  },\n});\n\nconst arrayOutputStrategy = <ELEMENT>(\n  schema: Schema<ELEMENT>,\n): OutputStrategy<ELEMENT[], ELEMENT[], AsyncIterableStream<ELEMENT>> => {\n  // remove $schema from schema.jsonSchema:\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n\n  return {\n    type: 'enum',\n\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      type: 'object',\n      properties: {\n        elements: { type: 'array', items: itemSchema },\n      },\n      required: ['elements'],\n      additionalProperties: false,\n    },\n\n    validatePartialResult({ value, latestObject, isFirstDelta, isFinalDelta }) {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n      const resultArray: Array<ELEMENT> = [];\n\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = safeValidateTypes({ value: element, schema });\n\n        // special treatment for last processed element:\n        // ignore parse or validation failures, since they indicate that the\n        // last element is incomplete and should not be included in the result,\n        // unless it is the final delta\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n\n        if (!result.success) {\n          return result;\n        }\n\n        resultArray.push(result.value);\n      }\n\n      // calculate delta:\n      const publishedElementCount = latestObject?.length ?? 0;\n\n      let textDelta = '';\n\n      if (isFirstDelta) {\n        textDelta += '[';\n      }\n\n      if (publishedElementCount > 0) {\n        textDelta += ',';\n      }\n\n      textDelta += resultArray\n        .slice(publishedElementCount) // only new elements\n        .map(element => JSON.stringify(element))\n        .join(',');\n\n      if (isFinalDelta) {\n        textDelta += ']';\n      }\n\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta,\n        },\n      };\n    },\n\n    validateFinalResult(\n      value: JSONValue | undefined,\n    ): ValidationResult<Array<ELEMENT>> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n\n      // check that each element in the array is of the correct type:\n      for (const element of inputArray) {\n        const result = safeValidateTypes({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n\n      return { success: true, value: inputArray as Array<ELEMENT> };\n    },\n\n    createElementStream(\n      originalStream: ReadableStream<ObjectStreamPart<ELEMENT[]>>,\n    ) {\n      let publishedElements = 0;\n\n      return createAsyncIterableStream(originalStream, {\n        transform(chunk, controller) {\n          switch (chunk.type) {\n            case 'object': {\n              const array = chunk.object;\n\n              // publish new elements one by one:\n              for (; publishedElements < array.length; publishedElements++) {\n                controller.enqueue(array[publishedElements]);\n              }\n\n              break;\n            }\n\n            case 'text-delta':\n            case 'finish':\n              break;\n\n            case 'error':\n              controller.error(chunk.error);\n              break;\n\n            default: {\n              const _exhaustiveCheck: never = chunk;\n              throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n            }\n          }\n        },\n      });\n    },\n  };\n};\n\nconst enumOutputStrategy = <ENUM extends string>(\n  enumValues: Array<ENUM>,\n): OutputStrategy<ENUM, ENUM, never> => {\n  return {\n    type: 'enum',\n\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      type: 'object',\n      properties: {\n        result: { type: 'string', enum: enumValues },\n      },\n      required: ['result'],\n      additionalProperties: false,\n    },\n\n    validateFinalResult(value: JSONValue | undefined): ValidationResult<ENUM> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || typeof value.result !== 'string') {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause:\n              'value must be an object that contains a string in the \"result\" property.',\n          }),\n        };\n      }\n\n      const result = value.result as string;\n\n      return enumValues.includes(result as ENUM)\n        ? { success: true, value: result as ENUM }\n        : {\n            success: false,\n            error: new TypeValidationError({\n              value,\n              cause: 'value must be a string in the enum',\n            }),\n          };\n    },\n\n    validatePartialResult() {\n      // no streaming in enum mode\n      throw new UnsupportedFunctionalityError({\n        functionality: 'partial results in enum mode',\n      });\n    },\n\n    createElementStream() {\n      // no streaming in enum mode\n      throw new UnsupportedFunctionalityError({\n        functionality: 'element streams in enum mode',\n      });\n    },\n  };\n};\n\nexport function getOutputStrategy<SCHEMA>({\n  output,\n  schema,\n  enumValues,\n}: {\n  output: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n  enumValues?: Array<SCHEMA>;\n}): OutputStrategy<any, any, any> {\n  switch (output) {\n    case 'object':\n      return objectOutputStrategy(asSchema(schema!));\n    case 'array':\n      return arrayOutputStrategy(asSchema(schema!));\n    case 'enum':\n      return enumOutputStrategy(enumValues! as Array<string>);\n    case 'no-schema':\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck: never = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n","export type AsyncIterableStream<T> = AsyncIterable<T> & ReadableStream<T>;\n\nexport function createAsyncIterableStream<S, T>(\n  source: ReadableStream<S>,\n  transformer: Transformer<S, T>,\n): AsyncIterableStream<T> {\n  const transformedStream: any = source.pipeThrough(\n    new TransformStream(transformer),\n  );\n\n  transformedStream[Symbol.asyncIterator] = () => {\n    const reader = transformedStream.getReader();\n    return {\n      async next(): Promise<IteratorResult<string>> {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: undefined } : { done: false, value };\n      },\n    };\n  };\n\n  return transformedStream;\n}\n","import { z } from 'zod';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { Schema } from '@ai-sdk/ui-utils';\n\nexport function validateObjectGenerationInput({\n  output,\n  mode,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues,\n}: {\n  output?: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: z.Schema<any, z.ZodTypeDef, any> | Schema<any>;\n  schemaName?: string;\n  schemaDescription?: string;\n  enumValues?: Array<unknown>;\n  mode?: 'auto' | 'json' | 'tool';\n}) {\n  if (\n    output != null &&\n    output !== 'object' &&\n    output !== 'array' &&\n    output !== 'enum' &&\n    output !== 'no-schema'\n  ) {\n    throw new InvalidArgumentError({\n      parameter: 'output',\n      value: output,\n      message: 'Invalid output type.',\n    });\n  }\n\n  if (output === 'no-schema') {\n    if (mode === 'auto' || mode === 'tool') {\n      throw new InvalidArgumentError({\n        parameter: 'mode',\n        value: mode,\n        message: 'Mode must be \"json\" for no-schema output.',\n      });\n    }\n\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for no-schema output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for no-schema output.',\n      });\n    }\n  }\n\n  if (output === 'object') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is required for object output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for object output.',\n      });\n    }\n  }\n\n  if (output === 'array') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Element schema is required for array output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for array output.',\n      });\n    }\n  }\n\n  if (output === 'enum') {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for enum output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for enum output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for enum output.',\n      });\n    }\n\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are required for enum output.',\n      });\n    }\n\n    for (const value of enumValues) {\n      if (typeof value !== 'string') {\n        throw new InvalidArgumentError({\n          parameter: 'enumValues',\n          value,\n          message: 'Enum values must be strings.',\n        });\n      }\n    }\n  }\n}\n","import {\n  JSONValue,\n  LanguageModelV1CallOptions,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport { createIdGenerator } from '@ai-sdk/provider-utils';\nimport {\n  DeepPartial,\n  Schema,\n  isDeepEqualData,\n  parsePartialJson,\n} from '@ai-sdk/ui-utils';\nimport { Span } from '@opentelemetry/api';\nimport { ServerResponse } from 'http';\nimport { z } from 'zod';\nimport { createResolvablePromise } from '../../util/create-resolvable-promise';\nimport { DelayedPromise } from '../../util/delayed-promise';\nimport { retryWithExponentialBackoff } from '../../util/retry-with-exponential-backoff';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LanguageModelResponseMetadata,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport {\n  LanguageModelUsage,\n  calculateLanguageModelUsage,\n} from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { OutputStrategy, getOutputStrategy } from './output-strategy';\nimport { ObjectStreamPart, StreamObjectResult } from './stream-object-result';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\ntype OnFinishCallback<RESULT> = (event: {\n  /**\nThe token usage of the generated response.\n*/\n  usage: LanguageModelUsage;\n\n  /**\nThe generated object. Can be undefined if the final object does not match the schema.\n*/\n  object: RESULT | undefined;\n\n  /**\nOptional error object. This is e.g. a TypeValidationError when the final object does not match the schema.\n*/\n  error: unknown | undefined;\n\n  /**\nOptional raw response data.\n\n@deprecated Use `response` instead.\n       */\n  rawResponse?: {\n    /**\nResponse headers.\n   */\n    headers?: Record<string, string>;\n  };\n\n  /**\nResponse metadata.\n */\n  response: LanguageModelResponseMetadata;\n\n  /**\nWarnings from the model provider (e.g. unsupported settings).\n*/\n  warnings?: CallWarning[];\n\n  /**\nAdditional provider-specific metadata. They are passed through\nfrom the provider to the AI SDK and enable provider-specific\nresults that can be fully encapsulated in the provider.\n*/\n  experimental_providerMetadata: ProviderMetadata | undefined;\n}) => Promise<void> | void;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport async function streamObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: OnFinishCallback<OBJECT>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): Promise<StreamObjectResult<DeepPartial<OBJECT>, OBJECT, never>>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport async function streamObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: OnFinishCallback<Array<ELEMENT>>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): Promise<\n  StreamObjectResult<\n    Array<ELEMENT>,\n    Array<ELEMENT>,\n    AsyncIterableStream<ELEMENT>\n  >\n>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport async function streamObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: OnFinishCallback<JSONValue>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): Promise<StreamObjectResult<JSONValue, JSONValue, never>>;\nexport async function streamObject<SCHEMA, PARTIAL, RESULT, ELEMENT_STREAM>({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  onFinish,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n    now = originalNow,\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'no-schema';\n\n    model: LanguageModel;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_telemetry?: TelemetrySettings;\n    experimental_providerMetadata?: ProviderMetadata;\n    onFinish?: OnFinishCallback<RESULT>;\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n      now?: () => number;\n    };\n  }): Promise<StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>> {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n  });\n\n  const outputStrategy = getOutputStrategy({ output, schema: inputSchema });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  const retry = retryWithExponentialBackoff({ maxRetries });\n\n  return recordSpan({\n    name: 'ai.streamObject',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.streamObject',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.schema':\n          outputStrategy.jsonSchema != null\n            ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n            : undefined,\n        'ai.schema.name': schemaName,\n        'ai.schema.description': schemaDescription,\n        'ai.settings.output': outputStrategy.type,\n        'ai.settings.mode': mode,\n      },\n    }),\n    tracer,\n    endWhenDone: false,\n    fn: async rootSpan => {\n      // use the default provider mode when the mode is set to 'auto' or unspecified\n      if (mode === 'auto' || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n\n      let callOptions: LanguageModelV1CallOptions;\n      let transformer: Transformer<\n        LanguageModelV1StreamPart,\n        string | Omit<LanguageModelV1StreamPart, 'text-delta'>\n      >;\n\n      switch (mode) {\n        case 'json': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: {\n              system:\n                outputStrategy.jsonSchema == null\n                  ? injectJsonInstruction({ prompt: system })\n                  : model.supportsStructuredOutputs\n                  ? system\n                  : injectJsonInstruction({\n                      prompt: system,\n                      schema: outputStrategy.jsonSchema,\n                    }),\n              prompt,\n              messages,\n            },\n            tools: undefined,\n          });\n\n          callOptions = {\n            mode: {\n              type: 'object-json',\n              schema: outputStrategy.jsonSchema,\n              name: schemaName,\n              description: schemaDescription,\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: standardizedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n              prompt: standardizedPrompt,\n              modelSupportsImageUrls: model.supportsImageUrls,\n              modelSupportsUrl: model.supportsUrl,\n            }),\n            providerMetadata,\n            abortSignal,\n            headers,\n          };\n\n          transformer = {\n            transform: (chunk, controller) => {\n              switch (chunk.type) {\n                case 'text-delta':\n                  controller.enqueue(chunk.textDelta);\n                  break;\n                case 'response-metadata':\n                case 'finish':\n                case 'error':\n                  controller.enqueue(chunk);\n                  break;\n              }\n            },\n          };\n\n          break;\n        }\n\n        case 'tool': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: { system, prompt, messages },\n            tools: undefined,\n          });\n\n          callOptions = {\n            mode: {\n              type: 'object-tool',\n              tool: {\n                type: 'function',\n                name: schemaName ?? 'json',\n                description: schemaDescription ?? 'Respond with a JSON object.',\n                parameters: outputStrategy.jsonSchema!,\n              },\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: standardizedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n              prompt: standardizedPrompt,\n              modelSupportsImageUrls: model.supportsImageUrls,\n              modelSupportsUrl: model.supportsUrl,\n            }),\n            providerMetadata,\n            abortSignal,\n            headers,\n          };\n\n          transformer = {\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case 'tool-call-delta':\n                  controller.enqueue(chunk.argsTextDelta);\n                  break;\n                case 'response-metadata':\n                case 'finish':\n                case 'error':\n                  controller.enqueue(chunk);\n                  break;\n              }\n            },\n          };\n\n          break;\n        }\n\n        case undefined: {\n          throw new Error(\n            'Model does not have a default object generation mode.',\n          );\n        }\n\n        default: {\n          const _exhaustiveCheck: never = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n\n      const {\n        result: { stream, warnings, rawResponse, request },\n        doStreamSpan,\n        startTimestampMs,\n      } = await retry(() =>\n        recordSpan({\n          name: 'ai.streamObject.doStream',\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: 'ai.streamObject.doStream',\n                telemetry,\n              }),\n              ...baseTelemetryAttributes,\n              'ai.prompt.format': {\n                input: () => callOptions.inputFormat,\n              },\n              'ai.prompt.messages': {\n                input: () => JSON.stringify(callOptions.prompt),\n              },\n              'ai.settings.mode': mode,\n\n              // standardized gen-ai llm span attributes:\n              'gen_ai.system': model.provider,\n              'gen_ai.request.model': model.modelId,\n              'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n              'gen_ai.request.max_tokens': settings.maxTokens,\n              'gen_ai.request.presence_penalty': settings.presencePenalty,\n              'gen_ai.request.temperature': settings.temperature,\n              'gen_ai.request.top_k': settings.topK,\n              'gen_ai.request.top_p': settings.topP,\n            },\n          }),\n          tracer,\n          endWhenDone: false,\n          fn: async doStreamSpan => ({\n            startTimestampMs: now(),\n            doStreamSpan,\n            result: await model.doStream(callOptions),\n          }),\n        }),\n      );\n\n      return new DefaultStreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>({\n        outputStrategy,\n        stream: stream.pipeThrough(new TransformStream(transformer)),\n        warnings,\n        rawResponse,\n        request: request ?? {},\n        onFinish,\n        rootSpan,\n        doStreamSpan,\n        telemetry,\n        startTimestampMs,\n        modelId: model.modelId,\n        now,\n        currentDate,\n        generateId,\n      });\n    },\n  });\n}\n\nclass DefaultStreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n  implements StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n{\n  private readonly originalStream: ReadableStream<ObjectStreamPart<PARTIAL>>;\n  private readonly objectPromise: DelayedPromise<RESULT>;\n\n  readonly request: StreamObjectResult<\n    PARTIAL,\n    RESULT,\n    ELEMENT_STREAM\n  >['request'];\n\n  readonly warnings: StreamObjectResult<\n    PARTIAL,\n    RESULT,\n    ELEMENT_STREAM\n  >['warnings'];\n  readonly usage: StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>['usage'];\n  readonly experimental_providerMetadata: StreamObjectResult<\n    PARTIAL,\n    RESULT,\n    ELEMENT_STREAM\n  >['experimental_providerMetadata'];\n  readonly rawResponse: StreamObjectResult<\n    PARTIAL,\n    RESULT,\n    ELEMENT_STREAM\n  >['rawResponse'];\n  readonly outputStrategy: OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM>;\n  readonly response: StreamObjectResult<\n    PARTIAL,\n    RESULT,\n    ELEMENT_STREAM\n  >['response'];\n\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    request,\n    outputStrategy,\n    onFinish,\n    rootSpan,\n    doStreamSpan,\n    telemetry,\n    startTimestampMs,\n    modelId,\n    now,\n    currentDate,\n    generateId,\n  }: {\n    stream: ReadableStream<\n      string | Omit<LanguageModelV1StreamPart, 'text-delta'>\n    >;\n    warnings: StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>['warnings'];\n    rawResponse: StreamObjectResult<\n      PARTIAL,\n      RESULT,\n      ELEMENT_STREAM\n    >['rawResponse'];\n    request: Awaited<\n      StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>['request']\n    >;\n    outputStrategy: OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM>;\n    onFinish: OnFinishCallback<RESULT> | undefined;\n    rootSpan: Span;\n    doStreamSpan: Span;\n    telemetry: TelemetrySettings | undefined;\n    startTimestampMs: number;\n    modelId: string;\n    now: () => number;\n    currentDate: () => Date;\n    generateId: () => string;\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    this.outputStrategy = outputStrategy;\n    this.request = Promise.resolve(request);\n\n    // initialize object promise\n    this.objectPromise = new DelayedPromise<RESULT>();\n\n    // initialize usage promise\n    const { resolve: resolveUsage, promise: usagePromise } =\n      createResolvablePromise<LanguageModelUsage>();\n    this.usage = usagePromise;\n\n    // initialize response promise\n    const { resolve: resolveResponse, promise: responsePromise } =\n      createResolvablePromise<LanguageModelResponseMetadata>();\n    this.response = responsePromise;\n\n    // initialize experimental_providerMetadata promise\n    const {\n      resolve: resolveProviderMetadata,\n      promise: providerMetadataPromise,\n    } = createResolvablePromise<ProviderMetadata | undefined>();\n    this.experimental_providerMetadata = providerMetadataPromise;\n\n    // store information for onFinish callback:\n    let usage: LanguageModelUsage | undefined;\n    let finishReason: LanguageModelV1FinishReason | undefined;\n    let providerMetadata: ProviderMetadata | undefined;\n    let object: RESULT | undefined;\n    let error: unknown | undefined;\n\n    // pipe chunks through a transformation stream that extracts metadata:\n    let accumulatedText = '';\n    let textDelta = '';\n    let response: {\n      id: string;\n      timestamp: Date;\n      modelId: string;\n    } = {\n      id: generateId(),\n      timestamp: currentDate(),\n      modelId,\n    };\n\n    // Keep track of raw parse result before type validation, since e.g. Zod might\n    // change the object by mapping properties.\n    let latestObjectJson: JSONValue | undefined = undefined;\n    let latestObject: PARTIAL | undefined = undefined;\n    let isFirstChunk = true;\n    let isFirstDelta = true;\n\n    const self = this;\n    this.originalStream = stream.pipeThrough(\n      new TransformStream<\n        string | ObjectStreamInputPart,\n        ObjectStreamPart<PARTIAL>\n      >({\n        async transform(chunk, controller): Promise<void> {\n          // Telemetry event for first chunk:\n          if (isFirstChunk) {\n            const msToFirstChunk = now() - startTimestampMs;\n\n            isFirstChunk = false;\n\n            doStreamSpan.addEvent('ai.stream.firstChunk', {\n              'ai.stream.msToFirstChunk': msToFirstChunk,\n            });\n\n            doStreamSpan.setAttributes({\n              'ai.stream.msToFirstChunk': msToFirstChunk,\n            });\n          }\n\n          // process partial text chunks\n          if (typeof chunk === 'string') {\n            accumulatedText += chunk;\n            textDelta += chunk;\n\n            const { value: currentObjectJson, state: parseState } =\n              parsePartialJson(accumulatedText);\n\n            if (\n              currentObjectJson !== undefined &&\n              !isDeepEqualData(latestObjectJson, currentObjectJson)\n            ) {\n              const validationResult = outputStrategy.validatePartialResult({\n                value: currentObjectJson,\n                textDelta,\n                latestObject,\n                isFirstDelta,\n                isFinalDelta: parseState === 'successful-parse',\n              });\n\n              if (\n                validationResult.success &&\n                !isDeepEqualData(latestObject, validationResult.value.partial)\n              ) {\n                // inside inner check to correctly parse the final element in array mode:\n                latestObjectJson = currentObjectJson;\n                latestObject = validationResult.value.partial;\n\n                controller.enqueue({\n                  type: 'object',\n                  object: latestObject,\n                });\n\n                controller.enqueue({\n                  type: 'text-delta',\n                  textDelta: validationResult.value.textDelta,\n                });\n\n                textDelta = '';\n                isFirstDelta = false;\n              }\n            }\n\n            return;\n          }\n\n          switch (chunk.type) {\n            case 'response-metadata': {\n              response = {\n                id: chunk.id ?? response.id,\n                timestamp: chunk.timestamp ?? response.timestamp,\n                modelId: chunk.modelId ?? response.modelId,\n              };\n              break;\n            }\n\n            case 'finish': {\n              // send final text delta:\n              if (textDelta !== '') {\n                controller.enqueue({ type: 'text-delta', textDelta });\n              }\n\n              // store finish reason for telemetry:\n              finishReason = chunk.finishReason;\n\n              // store usage and metadata for promises and onFinish callback:\n              usage = calculateLanguageModelUsage(chunk.usage);\n              providerMetadata = chunk.providerMetadata;\n\n              controller.enqueue({ ...chunk, usage, response });\n\n              // resolve promises that can be resolved now:\n              resolveUsage(usage);\n              resolveProviderMetadata(providerMetadata);\n              resolveResponse({\n                ...response,\n                headers: rawResponse?.headers,\n              });\n\n              // resolve the object promise with the latest object:\n              const validationResult =\n                outputStrategy.validateFinalResult(latestObjectJson);\n\n              if (validationResult.success) {\n                object = validationResult.value;\n                self.objectPromise.resolve(object);\n              } else {\n                error = validationResult.error;\n                self.objectPromise.reject(error);\n              }\n\n              break;\n            }\n\n            default: {\n              controller.enqueue(chunk);\n              break;\n            }\n          }\n        },\n\n        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n        async flush(controller) {\n          try {\n            const finalUsage = usage ?? {\n              promptTokens: NaN,\n              completionTokens: NaN,\n              totalTokens: NaN,\n            };\n\n            doStreamSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  'ai.response.finishReason': finishReason,\n                  'ai.response.object': {\n                    output: () => JSON.stringify(object),\n                  },\n                  'ai.response.id': response.id,\n                  'ai.response.model': response.modelId,\n                  'ai.response.timestamp': response.timestamp.toISOString(),\n\n                  'ai.usage.promptTokens': finalUsage.promptTokens,\n                  'ai.usage.completionTokens': finalUsage.completionTokens,\n\n                  // deprecated\n                  'ai.finishReason': finishReason,\n                  'ai.result.object': { output: () => JSON.stringify(object) },\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.response.finish_reasons': [finishReason],\n                  'gen_ai.response.id': response.id,\n                  'gen_ai.response.model': response.modelId,\n                  'gen_ai.usage.input_tokens': finalUsage.promptTokens,\n                  'gen_ai.usage.output_tokens': finalUsage.completionTokens,\n                },\n              }),\n            );\n\n            // finish doStreamSpan before other operations for correct timing:\n            doStreamSpan.end();\n\n            // Add response information to the root span:\n            rootSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  'ai.usage.promptTokens': finalUsage.promptTokens,\n                  'ai.usage.completionTokens': finalUsage.completionTokens,\n                  'ai.response.object': {\n                    output: () => JSON.stringify(object),\n                  },\n\n                  // deprecated\n                  'ai.result.object': { output: () => JSON.stringify(object) },\n                },\n              }),\n            );\n\n            // call onFinish callback:\n            await onFinish?.({\n              usage: finalUsage,\n              object,\n              error,\n              rawResponse,\n              response: {\n                ...response,\n                headers: rawResponse?.headers,\n              },\n              warnings,\n              experimental_providerMetadata: providerMetadata,\n            });\n          } catch (error) {\n            controller.error(error);\n          } finally {\n            rootSpan.end();\n          }\n        },\n      }),\n    );\n  }\n\n  get object(): Promise<RESULT> {\n    return this.objectPromise.value;\n  }\n\n  get partialObjectStream(): AsyncIterableStream<PARTIAL> {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case 'object':\n            controller.enqueue(chunk.object);\n            break;\n\n          case 'text-delta':\n          case 'finish':\n            break;\n\n          case 'error':\n            controller.error(chunk.error);\n            break;\n\n          default: {\n            const _exhaustiveCheck: never = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      },\n    });\n  }\n\n  get elementStream(): ELEMENT_STREAM {\n    return this.outputStrategy.createElementStream(this.originalStream);\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case 'text-delta':\n            controller.enqueue(chunk.textDelta);\n            break;\n\n          case 'object':\n          case 'finish':\n            break;\n\n          case 'error':\n            controller.error(chunk.error);\n            break;\n\n          default: {\n            const _exhaustiveCheck: never = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      },\n    });\n  }\n\n  get fullStream(): AsyncIterableStream<ObjectStreamPart<PARTIAL>> {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      },\n    });\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n\n/**\n * @deprecated Use `streamObject` instead.\n */\nexport const experimental_streamObject = streamObject;\n\nexport type ObjectStreamInputPart =\n  | {\n      type: 'error';\n      error: unknown;\n    }\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      logprobs?: LogProbs;\n      usage: LanguageModelUsage;\n      providerMetadata?: ProviderMetadata;\n    };\n","/**\n * Creates a Promise with externally accessible resolve and reject functions.\n *\n * @template T - The type of the value that the Promise will resolve to.\n * @returns An object containing:\n *   - promise: A Promise that can be resolved or rejected externally.\n *   - resolve: A function to resolve the Promise with a value of type T.\n *   - reject: A function to reject the Promise with an error.\n */\nexport function createResolvablePromise<T = any>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (error: unknown) => void;\n} {\n  let resolve: (value: T) => void;\n  let reject: (error: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  };\n}\n","/**\n * Delayed promise. It is only constructed once the value is accessed.\n * This is useful to avoid unhandled promise rejections when the promise is created\n * but not accessed.\n */\nexport class DelayedPromise<T> {\n  private status:\n    | { type: 'pending' }\n    | { type: 'resolved'; value: T }\n    | { type: 'rejected'; error: unknown } = { type: 'pending' };\n  private promise: Promise<T> | undefined;\n  private _resolve: undefined | ((value: T) => void) = undefined;\n  private _reject: undefined | ((error: unknown) => void) = undefined;\n\n  get value(): Promise<T> {\n    if (this.promise) {\n      return this.promise;\n    }\n\n    this.promise = new Promise<T>((resolve, reject) => {\n      if (this.status.type === 'resolved') {\n        resolve(this.status.value);\n      } else if (this.status.type === 'rejected') {\n        reject(this.status.error);\n      }\n\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n\n    return this.promise;\n  }\n\n  resolve(value: T): void {\n    this.status = { type: 'resolved', value };\n\n    if (this.promise) {\n      this._resolve?.(value);\n    }\n  }\n\n  reject(error: unknown): void {\n    this.status = { type: 'rejected', error };\n\n    if (this.promise) {\n      this._reject?.(error);\n    }\n  }\n}\n","// Shim for performance.now() to support environments that don't have it:\nexport function now(): number {\n  return globalThis?.performance?.now() ?? Date.now();\n}\n","export function prepareOutgoingHttpHeaders(\n  init: ResponseInit | undefined,\n  {\n    contentType,\n    dataStreamVersion,\n  }: { contentType: string; dataStreamVersion?: 'v1' | undefined },\n) {\n  const headers: Record<string, string | number | string[]> = {};\n\n  if (init?.headers != null) {\n    for (const [key, value] of Object.entries(init.headers)) {\n      headers[key] = value;\n    }\n  }\n\n  if (headers['Content-Type'] == null) {\n    headers['Content-Type'] = contentType;\n  }\n\n  if (dataStreamVersion !== undefined) {\n    headers['X-Vercel-AI-Data-Stream'] = dataStreamVersion;\n  }\n\n  return headers;\n}\n","import { ServerResponse } from 'node:http';\n\n/**\n * Writes the content of a stream to a server response.\n */\nexport function writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n}: {\n  response: ServerResponse;\n  status?: number;\n  statusText?: string;\n  headers?: Record<string, string | number | string[]>;\n  stream: ReadableStream<Uint8Array>;\n}): void {\n  response.writeHead(status ?? 200, statusText, headers);\n\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        response.write(value);\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n\n  read();\n}\n","import { createIdGenerator } from '@ai-sdk/provider-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { InvalidArgumentError } from '../../errors';\nimport { retryWithExponentialBackoff } from '../../util/retry-with-exponential-backoff';\nimport { CoreAssistantMessage, CoreToolMessage } from '../prompt';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { CoreTool } from '../tool/tool';\nimport { CoreToolChoice, LanguageModel, ProviderMetadata } from '../types';\nimport {\n  LanguageModelUsage,\n  calculateLanguageModelUsage,\n} from '../types/usage';\nimport { removeTextAfterLastWhitespace } from '../util/remove-text-after-last-whitespace';\nimport { GenerateTextResult } from './generate-text-result';\nimport { parseToolCall } from './parse-tool-call';\nimport { StepResult } from './step-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallArray } from './tool-call';\nimport { ToolResultArray } from './tool-result';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aitxt', size: 24 });\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamText` instead.\n\n@param model - The language model to use.\n\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n@param toolChoice - The tool choice strategy. Default: 'auto'.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n\n@returns\nA result object that contains the generated text, the results of the tool calls, and additional information.\n */\nexport async function generateText<TOOLS extends Record<string, CoreTool>>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxAutomaticRoundtrips = 0,\n  maxToolRoundtrips = maxAutomaticRoundtrips,\n  maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1,\n  experimental_continuationSteps,\n  experimental_continueSteps: continueSteps = experimental_continuationSteps ??\n    false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  experimental_activeTools: activeTools,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  onStepFinish,\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n*/\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: CoreToolChoice<TOOLS>;\n\n    /**\n@deprecated Use `maxToolRoundtrips` instead.\n     */\n    maxAutomaticRoundtrips?: number;\n\n    /**\nMaximum number of automatic roundtrips for tool calls.\n\nAn automatic tool call roundtrip is another LLM call with the\ntool call results when all tool calls of the last assistant\nmessage have results.\n\nA maximum number is required to prevent infinite loops in the\ncase of misconfigured tools.\n\nBy default, it's set to 0, which will disable the feature.\n\n@deprecated Use `maxSteps` instead (which is `maxToolRoundtrips` + 1).\n     */\n    maxToolRoundtrips?: number;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n     */\n    maxSteps?: number;\n\n    /**\n@deprecated Use `experimental_continueSteps` instead.\n     */\n    experimental_continuationSteps?: boolean;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\n    Callback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: (event: StepResult<TOOLS>) => Promise<void> | void;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateTextResult<TOOLS>> {\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: 'maxSteps',\n      value: maxSteps,\n      message: 'maxSteps must be at least 1',\n    });\n  }\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const initialPrompt = standardizePrompt({\n    prompt: { system, prompt, messages },\n    tools,\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateText',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateText',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.settings.maxSteps': maxSteps,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n\n      const mode = {\n        type: 'regular' as const,\n        ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools }),\n      };\n\n      const callSettings = prepareCallSettings(settings);\n\n      let currentModelResponse: Awaited<\n        ReturnType<LanguageModel['doGenerate']>\n      > & { response: { id: string; timestamp: Date; modelId: string } };\n      let currentToolCalls: ToolCallArray<TOOLS> = [];\n      let currentToolResults: ToolResultArray<TOOLS> = [];\n      let stepCount = 0;\n      const responseMessages: Array<CoreAssistantMessage | CoreToolMessage> =\n        [];\n      let text = '';\n      const steps: GenerateTextResult<TOOLS>['steps'] = [];\n      const usage: LanguageModelUsage = {\n        completionTokens: 0,\n        promptTokens: 0,\n        totalTokens: 0,\n      };\n\n      let stepType: 'initial' | 'tool-result' | 'continue' | 'done' = 'initial';\n\n      do {\n        if (stepCount === 1) {\n          initialPrompt.type = 'messages';\n        }\n\n        // after the 1st step, we need to switch to messages format:\n        const promptFormat = stepCount === 0 ? initialPrompt.type : 'messages';\n\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: {\n            type: promptFormat,\n            system: initialPrompt.system,\n            messages: [...initialPrompt.messages, ...responseMessages],\n          },\n          modelSupportsImageUrls: model.supportsImageUrls,\n          modelSupportsUrl: model.supportsUrl,\n        });\n\n        currentModelResponse = await retry(() =>\n          recordSpan({\n            name: 'ai.generateText.doGenerate',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.generateText.doGenerate',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                'ai.prompt.format': { input: () => promptFormat },\n                'ai.prompt.messages': {\n                  input: () => JSON.stringify(promptMessages),\n                },\n                'ai.prompt.tools': {\n                  // convert the language model level tools:\n                  input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                },\n                'ai.prompt.toolChoice': {\n                  input: () =>\n                    mode.toolChoice != null\n                      ? JSON.stringify(mode.toolChoice)\n                      : undefined,\n                },\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': model.provider,\n                'gen_ai.request.model': model.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.stop_sequences': settings.stopSequences,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            fn: async span => {\n              const result = await model.doGenerate({\n                mode,\n                ...callSettings,\n                inputFormat: promptFormat,\n                prompt: promptMessages,\n                providerMetadata,\n                abortSignal,\n                headers,\n              });\n\n              // Fill in default values:\n              const responseData = {\n                id: result.response?.id ?? generateId(),\n                timestamp: result.response?.timestamp ?? currentDate(),\n                modelId: result.response?.modelId ?? model.modelId,\n              };\n\n              // Add response information to the span:\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.response.finishReason': result.finishReason,\n                    'ai.response.text': {\n                      output: () => result.text,\n                    },\n                    'ai.response.toolCalls': {\n                      output: () => JSON.stringify(result.toolCalls),\n                    },\n                    'ai.response.id': responseData.id,\n                    'ai.response.model': responseData.modelId,\n                    'ai.response.timestamp':\n                      responseData.timestamp.toISOString(),\n\n                    'ai.usage.promptTokens': result.usage.promptTokens,\n                    'ai.usage.completionTokens': result.usage.completionTokens,\n\n                    // deprecated:\n                    'ai.finishReason': result.finishReason,\n                    'ai.result.text': {\n                      output: () => result.text,\n                    },\n                    'ai.result.toolCalls': {\n                      output: () => JSON.stringify(result.toolCalls),\n                    },\n\n                    // standardized gen-ai llm span attributes:\n                    'gen_ai.response.finish_reasons': [result.finishReason],\n                    'gen_ai.response.id': responseData.id,\n                    'gen_ai.response.model': responseData.modelId,\n                    'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                    'gen_ai.usage.output_tokens': result.usage.completionTokens,\n                  },\n                }),\n              );\n\n              return { ...result, response: responseData };\n            },\n          }),\n        );\n\n        // parse tool calls:\n        currentToolCalls = (currentModelResponse.toolCalls ?? []).map(\n          modelToolCall => parseToolCall({ toolCall: modelToolCall, tools }),\n        );\n\n        // execute tools:\n        currentToolResults =\n          tools == null\n            ? []\n            : await executeTools({\n                toolCalls: currentToolCalls,\n                tools,\n                tracer,\n                telemetry,\n                abortSignal,\n              });\n\n        // token usage:\n        const currentUsage = calculateLanguageModelUsage(\n          currentModelResponse.usage,\n        );\n        usage.completionTokens += currentUsage.completionTokens;\n        usage.promptTokens += currentUsage.promptTokens;\n        usage.totalTokens += currentUsage.totalTokens;\n\n        // check if another step is needed:\n        let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n        if (++stepCount < maxSteps) {\n          if (\n            continueSteps &&\n            currentModelResponse.finishReason === 'length' &&\n            // only use continue when there are no tool calls:\n            currentToolCalls.length === 0\n          ) {\n            nextStepType = 'continue';\n          } else if (\n            // there are tool calls:\n            currentToolCalls.length > 0 &&\n            // all current tool calls have results:\n            currentToolResults.length === currentToolCalls.length\n          ) {\n            nextStepType = 'tool-result';\n          }\n        }\n\n        // text:\n        const originalText = currentModelResponse.text ?? '';\n        const stepTextLeadingWhitespaceTrimmed =\n          stepType === 'continue' && // only for continue steps\n          text.trimEnd() !== text // only trim when there is preceding whitespace\n            ? originalText.trimStart()\n            : originalText;\n        const stepText =\n          nextStepType === 'continue'\n            ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed)\n            : stepTextLeadingWhitespaceTrimmed;\n\n        text =\n          nextStepType === 'continue' || stepType === 'continue'\n            ? text + stepText\n            : stepText;\n\n        // append to messages for potential next step:\n        if (stepType === 'continue') {\n          // continue step: update the last assistant message\n          // continue is only possible when there are no tool calls,\n          // so we can assume that there is a single last assistant message:\n          const lastMessage = responseMessages[\n            responseMessages.length - 1\n          ] as CoreAssistantMessage;\n\n          if (typeof lastMessage.content === 'string') {\n            lastMessage.content += stepText;\n          } else {\n            lastMessage.content.push({\n              text: stepText,\n              type: 'text',\n            });\n          }\n        } else {\n          responseMessages.push(\n            ...toResponseMessages({\n              text,\n              tools: tools ?? ({} as TOOLS),\n              toolCalls: currentToolCalls,\n              toolResults: currentToolResults,\n            }),\n          );\n        }\n\n        // Add step information (after response messages are updated):\n        const currentStepResult: StepResult<TOOLS> = {\n          stepType,\n          text: stepText,\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentUsage,\n          warnings: currentModelResponse.warnings,\n          logprobs: currentModelResponse.logprobs,\n          request: currentModelResponse.request ?? {},\n          response: {\n            ...currentModelResponse.response,\n            headers: currentModelResponse.rawResponse?.headers,\n\n            // deep clone msgs to avoid mutating past messages in multi-step:\n            messages: JSON.parse(JSON.stringify(responseMessages)),\n          },\n          experimental_providerMetadata: currentModelResponse.providerMetadata,\n          isContinued: nextStepType === 'continue',\n        };\n        steps.push(currentStepResult);\n        await onStepFinish?.(currentStepResult);\n\n        stepType = nextStepType;\n      } while (stepType !== 'done');\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': currentModelResponse.finishReason,\n            'ai.response.text': {\n              output: () => currentModelResponse.text,\n            },\n            'ai.response.toolCalls': {\n              output: () => JSON.stringify(currentModelResponse.toolCalls),\n            },\n\n            'ai.usage.promptTokens': currentModelResponse.usage.promptTokens,\n            'ai.usage.completionTokens':\n              currentModelResponse.usage.completionTokens,\n\n            // deprecated:\n            'ai.finishReason': currentModelResponse.finishReason,\n            'ai.result.text': {\n              output: () => currentModelResponse.text,\n            },\n            'ai.result.toolCalls': {\n              output: () => JSON.stringify(currentModelResponse.toolCalls),\n            },\n          },\n        }),\n      );\n\n      return new DefaultGenerateTextResult({\n        text,\n        toolCalls: currentToolCalls,\n        toolResults: currentToolResults,\n        finishReason: currentModelResponse.finishReason,\n        usage,\n        warnings: currentModelResponse.warnings,\n        request: currentModelResponse.request ?? {},\n        response: {\n          ...currentModelResponse.response,\n          headers: currentModelResponse.rawResponse?.headers,\n          messages: responseMessages,\n        },\n        logprobs: currentModelResponse.logprobs,\n        responseMessages,\n        steps,\n        providerMetadata: currentModelResponse.providerMetadata,\n      });\n    },\n  });\n}\n\nasync function executeTools<TOOLS extends Record<string, CoreTool>>({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  abortSignal,\n}: {\n  toolCalls: ToolCallArray<TOOLS>;\n  tools: TOOLS;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  abortSignal: AbortSignal | undefined;\n}): Promise<ToolResultArray<TOOLS>> {\n  const toolResults = await Promise.all(\n    toolCalls.map(async toolCall => {\n      const tool = tools[toolCall.toolName];\n\n      if (tool?.execute == null) {\n        return undefined;\n      }\n\n      const result = await recordSpan({\n        name: 'ai.toolCall',\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: 'ai.toolCall',\n              telemetry,\n            }),\n            'ai.toolCall.name': toolCall.toolName,\n            'ai.toolCall.id': toolCall.toolCallId,\n            'ai.toolCall.args': {\n              output: () => JSON.stringify(toolCall.args),\n            },\n          },\n        }),\n        tracer,\n        fn: async span => {\n          const result = await tool.execute!(toolCall.args, { abortSignal });\n\n          try {\n            span.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  'ai.toolCall.result': {\n                    output: () => JSON.stringify(result),\n                  },\n                },\n              }),\n            );\n          } catch (ignored) {\n            // JSON stringify might fail if the result is not serializable,\n            // in which case we just ignore it. In the future we might want to\n            // add an optional serialize method to the tool interface and warn\n            // if the result is not serializable.\n          }\n\n          return result;\n        },\n      });\n\n      return {\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        args: toolCall.args,\n        result,\n      } as ToolResultArray<TOOLS>[number];\n    }),\n  );\n\n  return toolResults.filter(\n    (result): result is NonNullable<typeof result> => result != null,\n  );\n}\n\nclass DefaultGenerateTextResult<TOOLS extends Record<string, CoreTool>>\n  implements GenerateTextResult<TOOLS>\n{\n  readonly text: GenerateTextResult<TOOLS>['text'];\n  readonly toolCalls: GenerateTextResult<TOOLS>['toolCalls'];\n  readonly toolResults: GenerateTextResult<TOOLS>['toolResults'];\n  readonly finishReason: GenerateTextResult<TOOLS>['finishReason'];\n  readonly usage: GenerateTextResult<TOOLS>['usage'];\n  readonly warnings: GenerateTextResult<TOOLS>['warnings'];\n  readonly responseMessages: GenerateTextResult<TOOLS>['responseMessages'];\n  readonly roundtrips: GenerateTextResult<TOOLS>['roundtrips'];\n  readonly steps: GenerateTextResult<TOOLS>['steps'];\n  readonly rawResponse: GenerateTextResult<TOOLS>['rawResponse'];\n  readonly logprobs: GenerateTextResult<TOOLS>['logprobs'];\n  readonly experimental_providerMetadata: GenerateTextResult<TOOLS>['experimental_providerMetadata'];\n  readonly response: GenerateTextResult<TOOLS>['response'];\n  readonly request: GenerateTextResult<TOOLS>['request'];\n  constructor(options: {\n    text: GenerateTextResult<TOOLS>['text'];\n    toolCalls: GenerateTextResult<TOOLS>['toolCalls'];\n    toolResults: GenerateTextResult<TOOLS>['toolResults'];\n    finishReason: GenerateTextResult<TOOLS>['finishReason'];\n    usage: GenerateTextResult<TOOLS>['usage'];\n    warnings: GenerateTextResult<TOOLS>['warnings'];\n    logprobs: GenerateTextResult<TOOLS>['logprobs'];\n    responseMessages: GenerateTextResult<TOOLS>['responseMessages'];\n    steps: GenerateTextResult<TOOLS>['steps'];\n    providerMetadata: GenerateTextResult<TOOLS>['experimental_providerMetadata'];\n    response: GenerateTextResult<TOOLS>['response'];\n    request: GenerateTextResult<TOOLS>['request'];\n  }) {\n    this.text = options.text;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.request = options.request;\n    this.response = options.response;\n    this.responseMessages = options.responseMessages;\n    this.roundtrips = options.steps;\n    this.steps = options.steps;\n    this.experimental_providerMetadata = options.providerMetadata;\n\n    // deprecated:\n    this.rawResponse = {\n      headers: options.response.headers,\n    };\n    this.logprobs = options.logprobs;\n  }\n}\n\n/**\n * @deprecated Use `generateText` instead.\n */\nexport const experimental_generateText = generateText;\n","export {\n  AISDKError,\n  APICallError,\n  EmptyResponseBodyError,\n  InvalidPromptError,\n  InvalidResponseDataError,\n  JSONParseError,\n  LoadAPIKeyError,\n  NoContentGeneratedError,\n  NoSuchModelError,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport { InvalidArgumentError } from './invalid-argument-error';\nexport { InvalidToolArgumentsError } from './invalid-tool-arguments-error';\nexport { NoSuchToolError } from './no-such-tool-error';\n\nexport { NoObjectGeneratedError } from '../core/generate-object/no-object-generated-error';\nexport { InvalidDataContentError } from '../core/prompt/invalid-data-content-error';\nexport { InvalidMessageRoleError } from '../core/prompt/invalid-message-role-error';\nexport { MessageConversionError } from '../core/prompt/message-conversion-error';\nexport { DownloadError } from '../util/download-error';\nexport { RetryError } from '../util/retry-error';\n","import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidToolArgumentsError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidToolArgumentsError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly toolArgs: string;\n\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${getErrorMessage(\n      cause,\n    )}`,\n  }: {\n    message?: string;\n    toolArgs: string;\n    toolName: string;\n    cause: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n\n  static isInstance(error: unknown): error is InvalidToolArgumentsError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidToolArgumentsError(\n    error: unknown,\n  ): error is InvalidToolArgumentsError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as InvalidToolArgumentsError).toolName === 'string' &&\n      typeof (error as InvalidToolArgumentsError).toolArgs === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n\n      toolName: this.toolName,\n      toolArgs: this.toolArgs,\n    };\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchToolError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchToolError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly availableTools: string[] | undefined;\n\n  constructor({\n    toolName,\n    availableTools = undefined,\n    message = `Model tried to call unavailable tool '${toolName}'. ${\n      availableTools === undefined\n        ? 'No tools are available.'\n        : `Available tools: ${availableTools.join(', ')}.`\n    }`,\n  }: {\n    toolName: string;\n    availableTools?: string[] | undefined;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n\n  static isInstance(error: unknown): error is NoSuchToolError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchToolError(error: unknown): error is NoSuchToolError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      'toolName' in error &&\n      error.toolName != undefined &&\n      typeof error.name === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      toolName: this.toolName,\n      availableTools: this.availableTools,\n    };\n  }\n}\n","import {\n  LanguageModelV1FunctionTool,\n  LanguageModelV1ProviderDefinedTool,\n  LanguageModelV1ToolChoice,\n} from '@ai-sdk/provider';\nimport { asSchema } from '@ai-sdk/ui-utils';\nimport { CoreTool } from '../tool/tool';\nimport { CoreToolChoice } from '../types/language-model';\nimport { isNonEmptyObject } from '../util/is-non-empty-object';\n\nexport function prepareToolsAndToolChoice<\n  TOOLS extends Record<string, CoreTool>,\n>({\n  tools,\n  toolChoice,\n  activeTools,\n}: {\n  tools: TOOLS | undefined;\n  toolChoice: CoreToolChoice<TOOLS> | undefined;\n  activeTools: Array<keyof TOOLS> | undefined;\n}): {\n  tools:\n    | Array<LanguageModelV1FunctionTool | LanguageModelV1ProviderDefinedTool>\n    | undefined;\n  toolChoice: LanguageModelV1ToolChoice | undefined;\n} {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: undefined,\n      toolChoice: undefined,\n    };\n  }\n\n  // when activeTools is provided, we only include the tools that are in the list:\n  const filteredTools =\n    activeTools != null\n      ? Object.entries(tools).filter(([name]) =>\n          activeTools.includes(name as keyof TOOLS),\n        )\n      : Object.entries(tools);\n\n  return {\n    tools: filteredTools.map(([name, tool]) => {\n      const toolType = tool.type;\n      switch (toolType) {\n        case undefined:\n        case 'function':\n          return {\n            type: 'function' as const,\n            name,\n            description: tool.description,\n            parameters: asSchema(tool.parameters).jsonSchema,\n          };\n        case 'provider-defined':\n          return {\n            type: 'provider-defined' as const,\n            name,\n            id: tool.id,\n            args: tool.args,\n          };\n        default: {\n          const exhaustiveCheck: never = toolType;\n          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n        }\n      }\n    }),\n    toolChoice:\n      toolChoice == null\n        ? { type: 'auto' }\n        : typeof toolChoice === 'string'\n        ? { type: toolChoice }\n        : { type: 'tool' as const, toolName: toolChoice.toolName as string },\n  };\n}\n","export function isNonEmptyObject(\n  object: Record<string, unknown> | undefined | null,\n): object is Record<string, unknown> {\n  return object != null && Object.keys(object).length > 0;\n}\n","const lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\n\n/**\n * Splits the text on the last whitespace.\n *\n * Whitespace is defined as one or more whitespace characters,\n * e.g. space, tab, newline, etc.\n *\n * @param text - The text to split.\n * @returns The prefix, whitespace, and suffix. Undefined if there is no whitespace.\n */\nexport function splitOnLastWhitespace(text: string):\n  | {\n      prefix: string;\n      whitespace: string;\n      suffix: string;\n    }\n  | undefined {\n  const match = text.match(lastWhitespaceRegexp);\n  return match\n    ? { prefix: match[1], whitespace: match[2], suffix: match[3] }\n    : undefined;\n}\n","import { splitOnLastWhitespace } from './split-on-last-whitespace';\n\nexport function removeTextAfterLastWhitespace(text: string): string {\n  const match = splitOnLastWhitespace(text);\n  return match ? match.prefix + match.whitespace : text;\n}\n","import { LanguageModelV1FunctionToolCall } from '@ai-sdk/provider';\nimport { safeParseJSON, safeValidateTypes } from '@ai-sdk/provider-utils';\nimport { Schema, asSchema } from '@ai-sdk/ui-utils';\nimport { InvalidToolArgumentsError } from '../../errors/invalid-tool-arguments-error';\nimport { NoSuchToolError } from '../../errors/no-such-tool-error';\nimport { CoreTool } from '../tool';\nimport { inferParameters } from '../tool/tool';\nimport { ToolCallUnion } from './tool-call';\n\nexport function parseToolCall<TOOLS extends Record<string, CoreTool>>({\n  toolCall,\n  tools,\n}: {\n  toolCall: LanguageModelV1FunctionToolCall;\n  tools?: TOOLS;\n}): ToolCallUnion<TOOLS> {\n  const toolName = toolCall.toolName as keyof TOOLS & string;\n\n  if (tools == null) {\n    throw new NoSuchToolError({ toolName: toolCall.toolName });\n  }\n\n  const tool = tools[toolName];\n\n  if (tool == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools),\n    });\n  }\n\n  const schema = asSchema(tool.parameters) as Schema<\n    inferParameters<TOOLS[keyof TOOLS]['parameters']>\n  >;\n\n  // when the tool call has no arguments, we try passing an empty object to the schema\n  // (many LLMs generate empty strings for tool calls with no arguments)\n  const parseResult =\n    toolCall.args.trim() === ''\n      ? safeValidateTypes({ value: {}, schema })\n      : safeParseJSON({ text: toolCall.args, schema });\n\n  if (parseResult.success === false) {\n    throw new InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error,\n    });\n  }\n\n  return {\n    type: 'tool-call',\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value,\n  };\n}\n","import {\n  CoreAssistantMessage,\n  CoreToolMessage,\n  ToolResultPart,\n} from '../prompt';\nimport { CoreTool } from '../tool/tool';\nimport { ToolCallArray } from './tool-call';\nimport { ToolResultArray } from './tool-result';\n\n/**\nConverts the result of a `generateText` call to a list of response messages.\n */\nexport function toResponseMessages<TOOLS extends Record<string, CoreTool>>({\n  text = '',\n  tools,\n  toolCalls,\n  toolResults,\n}: {\n  text: string | undefined;\n  tools: TOOLS;\n  toolCalls: ToolCallArray<TOOLS>;\n  toolResults: ToolResultArray<TOOLS>;\n}): Array<CoreAssistantMessage | CoreToolMessage> {\n  const responseMessages: Array<CoreAssistantMessage | CoreToolMessage> = [];\n\n  responseMessages.push({\n    role: 'assistant',\n    content: [{ type: 'text', text }, ...toolCalls],\n  });\n\n  if (toolResults.length > 0) {\n    responseMessages.push({\n      role: 'tool',\n      content: toolResults.map((toolResult): ToolResultPart => {\n        const tool = tools[toolResult.toolName];\n        return tool?.experimental_toToolResultContent != null\n          ? {\n              type: 'tool-result',\n              toolCallId: toolResult.toolCallId,\n              toolName: toolResult.toolName,\n              result: tool.experimental_toToolResultContent(toolResult.result),\n              experimental_content: tool.experimental_toToolResultContent(\n                toolResult.result,\n              ),\n            }\n          : {\n              type: 'tool-result',\n              toolCallId: toolResult.toolCallId,\n              toolName: toolResult.toolName,\n              result: toolResult.result,\n            };\n      }),\n    });\n  }\n\n  return responseMessages;\n}\n","import { createIdGenerator } from '@ai-sdk/provider-utils';\nimport { Span } from '@opentelemetry/api';\nimport { ServerResponse } from 'node:http';\nimport {\n  AIStreamCallbacksAndOptions,\n  CoreAssistantMessage,\n  CoreToolMessage,\n  formatStreamPart,\n  InvalidArgumentError,\n  StreamData,\n  TextStreamPart,\n} from '../../streams';\nimport { createResolvablePromise } from '../../util/create-resolvable-promise';\nimport { retryWithExponentialBackoff } from '../../util/retry-with-exponential-backoff';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { CoreTool } from '../tool';\nimport {\n  CallWarning,\n  CoreToolChoice,\n  FinishReason,\n  LanguageModel,\n  LanguageModelRequestMetadata,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { LanguageModelUsage } from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { mergeStreams } from '../util/merge-streams';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { splitOnLastWhitespace } from '../util/split-on-last-whitespace';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport {\n  runToolsTransformation,\n  SingleRequestTextStreamPart,\n} from './run-tools-transformation';\nimport { StepResult } from './step-result';\nimport { StreamTextResult } from './stream-text-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolResultUnion } from './tool-result';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aitxt', size: 24 });\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateText` instead.\n\n@param model - The language model to use.\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n\n@param onChunk - Callback that is called for each chunk of the stream. The stream processing will pause until the callback promise is resolved.\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n@param onFinish - Callback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\n@return\nA result object for accessing different stream types and additional information.\n */\nexport async function streamText<TOOLS extends Record<string, CoreTool>>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxToolRoundtrips = 0,\n  maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  experimental_toolCallStreaming: toolCallStreaming = false,\n  experimental_activeTools: activeTools,\n  onChunk,\n  onFinish,\n  onStepFinish,\n  _internal: {\n    now = originalNow,\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n    */\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: CoreToolChoice<TOOLS>;\n\n    /**\nMaximum number of automatic roundtrips for tool calls.\n\nAn automatic tool call roundtrip is another LLM call with the\ntool call results when all tool calls of the last assistant\nmessage have results.\n\nA maximum number is required to prevent infinite loops in the\ncase of misconfigured tools.\n\nBy default, it's set to 0, which will disable the feature.\n\n@deprecated Use `maxSteps` instead (which is `maxToolRoundtrips` + 1).\n     */\n    maxToolRoundtrips?: number;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n */\n    maxSteps?: number;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\nEnable streaming of tool call deltas as they are generated. Disabled by default.\n     */\n    experimental_toolCallStreaming?: boolean;\n\n    /**\nCallback that is called for each chunk of the stream. The stream processing will pause until the callback promise is resolved.\n     */\n    onChunk?: (event: {\n      chunk: Extract<\n        TextStreamPart<TOOLS>,\n        {\n          type:\n            | 'text-delta'\n            | 'tool-call'\n            | 'tool-call-streaming-start'\n            | 'tool-call-delta'\n            | 'tool-result';\n        }\n      >;\n    }) => Promise<void> | void;\n\n    /**\nCallback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\nThe usage is the combined usage of all steps.\n     */\n    onFinish?: (\n      event: Omit<StepResult<TOOLS>, 'stepType' | 'isContinued'> & {\n        /**\nDetails for all steps.\n       */\n        readonly steps: StepResult<TOOLS>[];\n\n        /**\nThe response messages that were generated during the call. It consists of an assistant message,\npotentially containing tool calls.\n\nWhen there are tool results, there is an additional tool message with the tool results that are available.\nIf there are tools that do not have execute functions, they are not included in the tool results and\nneed to be added separately.\n     */\n        readonly responseMessages: Array<\n          CoreAssistantMessage | CoreToolMessage\n        >;\n      },\n    ) => Promise<void> | void;\n\n    /**\n    Callback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: (event: StepResult<TOOLS>) => Promise<void> | void;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      now?: () => number;\n      generateId?: () => string;\n      currentDate?: () => Date;\n    };\n  }): Promise<StreamTextResult<TOOLS>> {\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: 'maxSteps',\n      value: maxSteps,\n      message: 'maxSteps must be at least 1',\n    });\n  }\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  const initialPrompt = standardizePrompt({\n    prompt: { system, prompt, messages },\n    tools,\n  });\n\n  return recordSpan({\n    name: 'ai.streamText',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.streamText', telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.settings.maxSteps': maxSteps,\n      },\n    }),\n    tracer,\n    endWhenDone: false,\n    fn: async rootSpan => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n\n      const startStep: StartStepFunction<TOOLS> = async ({\n        responseMessages,\n      }: {\n        responseMessages: Array<CoreAssistantMessage | CoreToolMessage>;\n      }) => {\n        // after the 1st step, we need to switch to messages format:\n        const promptFormat =\n          responseMessages.length === 0 ? initialPrompt.type : 'messages';\n\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: {\n            type: promptFormat,\n            system: initialPrompt.system,\n            messages: [...initialPrompt.messages, ...responseMessages],\n          },\n          modelSupportsImageUrls: model.supportsImageUrls,\n          modelSupportsUrl: model.supportsUrl,\n        });\n\n        const mode = {\n          type: 'regular' as const,\n          ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools }),\n        };\n\n        const {\n          result: { stream, warnings, rawResponse, request },\n          doStreamSpan,\n          startTimestampMs,\n        } = await retry(() =>\n          recordSpan({\n            name: 'ai.streamText.doStream',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.streamText.doStream',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                'ai.prompt.format': {\n                  input: () => promptFormat,\n                },\n                'ai.prompt.messages': {\n                  input: () => JSON.stringify(promptMessages),\n                },\n                'ai.prompt.tools': {\n                  // convert the language model level tools:\n                  input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                },\n                'ai.prompt.toolChoice': {\n                  input: () =>\n                    mode.toolChoice != null\n                      ? JSON.stringify(mode.toolChoice)\n                      : undefined,\n                },\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': model.provider,\n                'gen_ai.request.model': model.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.stop_sequences': settings.stopSequences,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async doStreamSpan => ({\n              startTimestampMs: now(), // get before the call\n              doStreamSpan,\n              result: await model.doStream({\n                mode,\n                ...prepareCallSettings(settings),\n                inputFormat: promptFormat,\n                prompt: promptMessages,\n                providerMetadata,\n                abortSignal,\n                headers,\n              }),\n            }),\n          }),\n        );\n\n        return {\n          result: {\n            stream: runToolsTransformation({\n              tools,\n              generatorStream: stream,\n              toolCallStreaming,\n              tracer,\n              telemetry,\n              abortSignal,\n            }),\n            warnings,\n            request: request ?? {},\n            rawResponse,\n          },\n          doStreamSpan,\n          startTimestampMs,\n        };\n      };\n\n      const {\n        result: { stream, warnings, rawResponse, request },\n        doStreamSpan,\n        startTimestampMs,\n      } = await startStep({ responseMessages: [] });\n\n      return new DefaultStreamTextResult({\n        stream,\n        warnings,\n        rawResponse,\n        request,\n        onChunk,\n        onFinish,\n        onStepFinish,\n        rootSpan,\n        doStreamSpan,\n        telemetry,\n        startTimestampMs,\n        maxSteps,\n        continueSteps,\n        startStep,\n        modelId: model.modelId,\n        now,\n        currentDate,\n        generateId,\n        tools,\n      });\n    },\n  });\n}\n\ntype StartStepFunction<TOOLS extends Record<string, CoreTool>> = (options: {\n  responseMessages: Array<CoreAssistantMessage | CoreToolMessage>;\n}) => Promise<{\n  result: {\n    stream: ReadableStream<SingleRequestTextStreamPart<TOOLS>>;\n    warnings: CallWarning[] | undefined;\n    rawResponse: { headers?: Record<string, string> } | undefined;\n    request: LanguageModelRequestMetadata;\n  };\n  doStreamSpan: Span;\n  startTimestampMs: number;\n}>;\n\nclass DefaultStreamTextResult<TOOLS extends Record<string, CoreTool>>\n  implements StreamTextResult<TOOLS>\n{\n  private originalStream: ReadableStream<TextStreamPart<TOOLS>>;\n\n  // TODO needs to be changed to readonly async in v4 (and only return value from last step)\n  // (can't change before v4 because of backwards compatibility)\n  warnings: StreamTextResult<TOOLS>['warnings'];\n  rawResponse: StreamTextResult<TOOLS>['rawResponse'];\n\n  readonly usage: StreamTextResult<TOOLS>['usage'];\n  readonly finishReason: StreamTextResult<TOOLS>['finishReason'];\n  readonly experimental_providerMetadata: StreamTextResult<TOOLS>['experimental_providerMetadata'];\n  readonly text: StreamTextResult<TOOLS>['text'];\n  readonly toolCalls: StreamTextResult<TOOLS>['toolCalls'];\n  readonly toolResults: StreamTextResult<TOOLS>['toolResults'];\n  readonly request: StreamTextResult<TOOLS>['request'];\n  readonly response: StreamTextResult<TOOLS>['response'];\n  readonly steps: StreamTextResult<TOOLS>['steps'];\n  readonly responseMessages: StreamTextResult<TOOLS>['responseMessages'];\n\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    request,\n    onChunk,\n    onFinish,\n    onStepFinish,\n    rootSpan,\n    doStreamSpan,\n    telemetry,\n    startTimestampMs,\n    maxSteps,\n    continueSteps,\n    startStep,\n    modelId,\n    now,\n    currentDate,\n    generateId,\n    tools,\n  }: {\n    stream: ReadableStream<SingleRequestTextStreamPart<TOOLS>>;\n    warnings: StreamTextResult<TOOLS>['warnings'];\n    rawResponse: StreamTextResult<TOOLS>['rawResponse'];\n    request: Awaited<StreamTextResult<TOOLS>['request']>;\n    onChunk: Parameters<typeof streamText>[0]['onChunk'];\n    onFinish:\n      | ((\n          event: Omit<StepResult<TOOLS>, 'stepType' | 'isContinued'> & {\n            steps: StepResult<TOOLS>[];\n            responseMessages: Array<CoreAssistantMessage | CoreToolMessage>;\n          },\n        ) => Promise<void> | void)\n      | undefined;\n    onStepFinish:\n      | ((event: StepResult<TOOLS>) => Promise<void> | void)\n      | undefined;\n    rootSpan: Span;\n    doStreamSpan: Span;\n    telemetry: TelemetrySettings | undefined;\n    startTimestampMs: number;\n    maxSteps: number;\n    continueSteps: boolean;\n    startStep: StartStepFunction<TOOLS>;\n    modelId: string;\n    now: () => number;\n    currentDate: () => Date;\n    generateId: () => string;\n    tools: TOOLS | undefined;\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n\n    // initialize usage promise\n    const { resolve: resolveUsage, promise: usagePromise } =\n      createResolvablePromise<LanguageModelUsage>();\n    this.usage = usagePromise;\n\n    // initialize finish reason promise\n    const { resolve: resolveFinishReason, promise: finishReasonPromise } =\n      createResolvablePromise<FinishReason>();\n    this.finishReason = finishReasonPromise;\n\n    // initialize text promise\n    const { resolve: resolveText, promise: textPromise } =\n      createResolvablePromise<string>();\n    this.text = textPromise;\n\n    // initialize toolCalls promise\n    const { resolve: resolveToolCalls, promise: toolCallsPromise } =\n      createResolvablePromise<ToolCallUnion<TOOLS>[]>();\n    this.toolCalls = toolCallsPromise;\n\n    // initialize toolResults promise\n    const { resolve: resolveToolResults, promise: toolResultsPromise } =\n      createResolvablePromise<ToolResultUnion<TOOLS>[]>();\n    this.toolResults = toolResultsPromise;\n\n    // initialize steps promise\n    const { resolve: resolveSteps, promise: stepsPromise } =\n      createResolvablePromise<StepResult<TOOLS>[]>();\n    this.steps = stepsPromise;\n\n    // initialize experimental_providerMetadata promise\n    const {\n      resolve: resolveProviderMetadata,\n      promise: providerMetadataPromise,\n    } = createResolvablePromise<ProviderMetadata | undefined>();\n    this.experimental_providerMetadata = providerMetadataPromise;\n\n    // initialize request promise\n    const { resolve: resolveRequest, promise: requestPromise } =\n      createResolvablePromise<LanguageModelRequestMetadata>();\n    this.request = requestPromise;\n\n    // initialize response promise\n    const { resolve: resolveResponse, promise: responsePromise } =\n      createResolvablePromise<Awaited<StreamTextResult<TOOLS>['response']>>();\n    this.response = responsePromise;\n\n    // initialize responseMessages promise\n    const {\n      resolve: resolveResponseMessages,\n      promise: responseMessagesPromise,\n    } =\n      createResolvablePromise<Array<CoreAssistantMessage | CoreToolMessage>>();\n    this.responseMessages = responseMessagesPromise;\n\n    // create a stitchable stream to send steps in a single response stream\n    const {\n      stream: stitchableStream,\n      addStream,\n      close: closeStitchableStream,\n    } = createStitchableStream<TextStreamPart<TOOLS>>();\n\n    this.originalStream = stitchableStream;\n\n    // collect step results\n    const stepResults: StepResult<TOOLS>[] = [];\n\n    const self = this;\n\n    // add the steps stream\n    function addStepStream({\n      stream,\n      startTimestamp,\n      doStreamSpan,\n      currentStep,\n      responseMessages,\n      usage = {\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0,\n      },\n      stepType,\n      previousStepText = '',\n      stepRequest,\n      hasLeadingWhitespace,\n    }: {\n      stream: ReadableStream<SingleRequestTextStreamPart<TOOLS>>;\n      startTimestamp: number;\n      doStreamSpan: Span;\n      currentStep: number;\n      responseMessages: Array<CoreAssistantMessage | CoreToolMessage>;\n      usage: LanguageModelUsage | undefined;\n      stepType: 'initial' | 'continue' | 'tool-result';\n      previousStepText?: string;\n      stepRequest: LanguageModelRequestMetadata;\n      hasLeadingWhitespace: boolean;\n    }) {\n      const stepToolCalls: ToolCallUnion<TOOLS>[] = [];\n      const stepToolResults: ToolResultUnion<TOOLS>[] = [];\n      let stepFinishReason: FinishReason = 'unknown';\n      let stepUsage: LanguageModelUsage = {\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0,\n      };\n      let stepProviderMetadata: ProviderMetadata | undefined;\n      let stepFirstChunk = true;\n      let stepText = '';\n      let fullStepText = stepType === 'continue' ? previousStepText : '';\n      let stepLogProbs: LogProbs | undefined;\n      let stepResponse: { id: string; timestamp: Date; modelId: string } = {\n        id: generateId(),\n        timestamp: currentDate(),\n        modelId,\n      };\n\n      // chunk buffer when using continue:\n      let chunkBuffer = '';\n      let chunkTextPublished = false;\n      let inWhitespacePrefix = true;\n      let hasWhitespaceSuffix = false; // for next step. when true, step ended with whitespace\n\n      async function publishTextChunk({\n        controller,\n        chunk,\n      }: {\n        controller: TransformStreamDefaultController<TextStreamPart<TOOLS>>;\n        chunk: TextStreamPart<TOOLS> & { type: 'text-delta' };\n      }) {\n        controller.enqueue(chunk);\n\n        stepText += chunk.textDelta;\n        fullStepText += chunk.textDelta;\n        chunkTextPublished = true;\n        hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n\n        await onChunk?.({ chunk });\n      }\n\n      addStream(\n        stream.pipeThrough(\n          new TransformStream<\n            SingleRequestTextStreamPart<TOOLS>,\n            TextStreamPart<TOOLS>\n          >({\n            async transform(chunk, controller): Promise<void> {\n              // Telemetry for first chunk:\n              if (stepFirstChunk) {\n                const msToFirstChunk = now() - startTimestamp;\n\n                stepFirstChunk = false;\n\n                doStreamSpan.addEvent('ai.stream.firstChunk', {\n                  'ai.response.msToFirstChunk': msToFirstChunk,\n\n                  // deprecated:\n                  'ai.stream.msToFirstChunk': msToFirstChunk,\n                });\n\n                doStreamSpan.setAttributes({\n                  'ai.response.msToFirstChunk': msToFirstChunk,\n\n                  // deprecated:\n                  'ai.stream.msToFirstChunk': msToFirstChunk,\n                });\n              }\n\n              // Filter out empty text deltas\n              if (chunk.type === 'text-delta' && chunk.textDelta.length === 0) {\n                return;\n              }\n\n              const chunkType = chunk.type;\n              switch (chunkType) {\n                case 'text-delta': {\n                  if (continueSteps) {\n                    // when a new step starts, leading whitespace is to be discarded\n                    // when there is already preceding whitespace in the chunk buffer\n                    const trimmedChunkText =\n                      inWhitespacePrefix && hasLeadingWhitespace\n                        ? chunk.textDelta.trimStart()\n                        : chunk.textDelta;\n\n                    if (trimmedChunkText.length === 0) {\n                      break;\n                    }\n\n                    inWhitespacePrefix = false;\n                    chunkBuffer += trimmedChunkText;\n\n                    const split = splitOnLastWhitespace(chunkBuffer);\n\n                    // publish the text until the last whitespace:\n                    if (split != null) {\n                      chunkBuffer = split.suffix;\n\n                      await publishTextChunk({\n                        controller,\n                        chunk: {\n                          type: 'text-delta',\n                          textDelta: split.prefix + split.whitespace,\n                        },\n                      });\n                    }\n                  } else {\n                    await publishTextChunk({ controller, chunk });\n                  }\n\n                  break;\n                }\n\n                case 'tool-call': {\n                  controller.enqueue(chunk);\n                  // store tool calls for onFinish callback and toolCalls promise:\n                  stepToolCalls.push(chunk);\n                  await onChunk?.({ chunk });\n                  break;\n                }\n\n                case 'tool-result': {\n                  controller.enqueue(chunk);\n                  // store tool results for onFinish callback and toolResults promise:\n                  stepToolResults.push(chunk);\n                  // as any needed, bc type inferences mixed up tool-result with tool-call\n                  await onChunk?.({ chunk: chunk as any });\n                  break;\n                }\n\n                case 'response-metadata': {\n                  stepResponse = {\n                    id: chunk.id ?? stepResponse.id,\n                    timestamp: chunk.timestamp ?? stepResponse.timestamp,\n                    modelId: chunk.modelId ?? stepResponse.modelId,\n                  };\n                  break;\n                }\n\n                case 'finish': {\n                  // Note: tool executions might not be finished yet when the finish event is emitted.\n                  // store usage and finish reason for promises and onFinish callback:\n                  stepUsage = chunk.usage;\n                  stepFinishReason = chunk.finishReason;\n                  stepProviderMetadata = chunk.experimental_providerMetadata;\n                  stepLogProbs = chunk.logprobs;\n\n                  // Telemetry for finish event timing\n                  // (since tool executions can take longer and distort calculations)\n                  const msToFinish = now() - startTimestamp;\n                  doStreamSpan.addEvent('ai.stream.finish');\n                  doStreamSpan.setAttributes({\n                    'ai.response.msToFinish': msToFinish,\n                    'ai.response.avgCompletionTokensPerSecond':\n                      (1000 * stepUsage.completionTokens) / msToFinish,\n                  });\n\n                  break;\n                }\n\n                case 'tool-call-streaming-start':\n                case 'tool-call-delta': {\n                  controller.enqueue(chunk);\n                  await onChunk?.({ chunk });\n                  break;\n                }\n\n                case 'error': {\n                  controller.enqueue(chunk);\n                  stepFinishReason = 'error';\n                  break;\n                }\n\n                default: {\n                  const exhaustiveCheck: never = chunkType;\n                  throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                }\n              }\n            },\n\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush(controller) {\n              const stepToolCallsJson =\n                stepToolCalls.length > 0\n                  ? JSON.stringify(stepToolCalls)\n                  : undefined;\n\n              // determine the next step type\n              let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n              if (currentStep + 1 < maxSteps) {\n                if (\n                  continueSteps &&\n                  stepFinishReason === 'length' &&\n                  // only use continue when there are no tool calls:\n                  stepToolCalls.length === 0\n                ) {\n                  nextStepType = 'continue';\n                } else if (\n                  // there are tool calls:\n                  stepToolCalls.length > 0 &&\n                  // all current tool calls have results:\n                  stepToolResults.length === stepToolCalls.length\n                ) {\n                  nextStepType = 'tool-result';\n                }\n              }\n\n              // when using continuation, publish buffer on final step or if there\n              // was no whitespace in the step:\n              if (\n                continueSteps &&\n                chunkBuffer.length > 0 &&\n                (nextStepType !== 'continue' || // when the next step is a regular step, publish the buffer\n                  (stepType === 'continue' && !chunkTextPublished)) // when the next step is a continue step, publish the buffer if no text was published in the step\n              ) {\n                await publishTextChunk({\n                  controller,\n                  chunk: {\n                    type: 'text-delta',\n                    textDelta: chunkBuffer,\n                  },\n                });\n                chunkBuffer = '';\n              }\n\n              // record telemetry information first to ensure best effort timing\n              try {\n                doStreamSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': stepFinishReason,\n                      'ai.response.text': { output: () => stepText },\n                      'ai.response.toolCalls': {\n                        output: () => stepToolCallsJson,\n                      },\n                      'ai.response.id': stepResponse.id,\n                      'ai.response.model': stepResponse.modelId,\n                      'ai.response.timestamp':\n                        stepResponse.timestamp.toISOString(),\n\n                      'ai.usage.promptTokens': stepUsage.promptTokens,\n                      'ai.usage.completionTokens': stepUsage.completionTokens,\n\n                      // deprecated\n                      'ai.finishReason': stepFinishReason,\n                      'ai.result.text': { output: () => stepText },\n                      'ai.result.toolCalls': {\n                        output: () => stepToolCallsJson,\n                      },\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [stepFinishReason],\n                      'gen_ai.response.id': stepResponse.id,\n                      'gen_ai.response.model': stepResponse.modelId,\n                      'gen_ai.usage.input_tokens': stepUsage.promptTokens,\n                      'gen_ai.usage.output_tokens': stepUsage.completionTokens,\n                    },\n                  }),\n                );\n              } catch (error) {\n                // ignore error setting telemetry attributes\n              } finally {\n                // finish doStreamSpan before other operations for correct timing:\n                doStreamSpan.end();\n              }\n\n              controller.enqueue({\n                type: 'step-finish',\n                finishReason: stepFinishReason,\n                usage: stepUsage,\n                experimental_providerMetadata: stepProviderMetadata,\n                logprobs: stepLogProbs,\n                response: {\n                  ...stepResponse,\n                },\n                isContinued: nextStepType === 'continue',\n              });\n\n              // append to messages for the next step:\n              if (stepType === 'continue') {\n                // continue step: update the last assistant message\n                // continue is only possible when there are no tool calls,\n                // so we can assume that there is a single last assistant message:\n                const lastMessage = responseMessages[\n                  responseMessages.length - 1\n                ] as CoreAssistantMessage;\n\n                if (typeof lastMessage.content === 'string') {\n                  lastMessage.content += stepText;\n                } else {\n                  lastMessage.content.push({\n                    text: stepText,\n                    type: 'text',\n                  });\n                }\n              } else {\n                responseMessages.push(\n                  ...toResponseMessages({\n                    text: stepText,\n                    tools: tools ?? ({} as TOOLS),\n                    toolCalls: stepToolCalls,\n                    toolResults: stepToolResults,\n                  }),\n                );\n              }\n\n              // Add step information (after response messages are updated):\n              const currentStepResult: StepResult<TOOLS> = {\n                stepType,\n                text: stepText,\n                toolCalls: stepToolCalls,\n                toolResults: stepToolResults,\n                finishReason: stepFinishReason,\n                usage: stepUsage,\n                warnings: self.warnings,\n                logprobs: stepLogProbs,\n                request: stepRequest,\n                rawResponse: self.rawResponse,\n                response: {\n                  ...stepResponse,\n                  headers: self.rawResponse?.headers,\n\n                  // deep clone msgs to avoid mutating past messages in multi-step:\n                  messages: JSON.parse(JSON.stringify(responseMessages)),\n                },\n                experimental_providerMetadata: stepProviderMetadata,\n                isContinued: nextStepType === 'continue',\n              };\n\n              stepResults.push(currentStepResult);\n\n              await onStepFinish?.(currentStepResult);\n\n              const combinedUsage = {\n                promptTokens: usage.promptTokens + stepUsage.promptTokens,\n                completionTokens:\n                  usage.completionTokens + stepUsage.completionTokens,\n                totalTokens: usage.totalTokens + stepUsage.totalTokens,\n              };\n\n              if (nextStepType !== 'done') {\n                // create call and doStream span:\n                const {\n                  result,\n                  doStreamSpan,\n                  startTimestampMs: startTimestamp,\n                } = await startStep({ responseMessages });\n\n                // update warnings and rawResponse:\n                self.warnings = result.warnings;\n                self.rawResponse = result.rawResponse;\n\n                // needs to add to stitchable stream\n                addStepStream({\n                  stream: result.stream,\n                  startTimestamp,\n                  doStreamSpan,\n                  currentStep: currentStep + 1,\n                  responseMessages,\n                  usage: combinedUsage,\n                  stepType: nextStepType,\n                  previousStepText: fullStepText,\n                  stepRequest: result.request,\n                  hasLeadingWhitespace: hasWhitespaceSuffix,\n                });\n\n                return;\n              }\n\n              try {\n                // enqueue the finish chunk:\n                controller.enqueue({\n                  type: 'finish',\n                  finishReason: stepFinishReason,\n                  usage: combinedUsage,\n                  experimental_providerMetadata: stepProviderMetadata,\n                  logprobs: stepLogProbs,\n                  response: {\n                    ...stepResponse,\n                  },\n                });\n\n                // close the stitchable stream\n                closeStitchableStream();\n\n                // Add response information to the root span:\n                rootSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': stepFinishReason,\n                      'ai.response.text': { output: () => fullStepText },\n                      'ai.response.toolCalls': {\n                        output: () => stepToolCallsJson,\n                      },\n\n                      'ai.usage.promptTokens': combinedUsage.promptTokens,\n                      'ai.usage.completionTokens':\n                        combinedUsage.completionTokens,\n\n                      // deprecated\n                      'ai.finishReason': stepFinishReason,\n                      'ai.result.text': { output: () => fullStepText },\n                      'ai.result.toolCalls': {\n                        output: () => stepToolCallsJson,\n                      },\n                    },\n                  }),\n                );\n\n                // resolve promises:\n                resolveUsage(combinedUsage);\n                resolveFinishReason(stepFinishReason!);\n                resolveText(fullStepText);\n                resolveToolCalls(stepToolCalls);\n                resolveProviderMetadata(stepProviderMetadata);\n                resolveToolResults(stepToolResults);\n                resolveRequest(stepRequest);\n                resolveResponse({\n                  ...stepResponse,\n                  headers: rawResponse?.headers,\n                  messages: responseMessages,\n                });\n                resolveSteps(stepResults);\n                resolveResponseMessages(responseMessages);\n\n                // call onFinish callback:\n                await onFinish?.({\n                  finishReason: stepFinishReason,\n                  logprobs: stepLogProbs,\n                  usage: combinedUsage,\n                  text: fullStepText,\n                  toolCalls: stepToolCalls,\n                  // The tool results are inferred as a never[] type, because they are\n                  // optional and the execute method with an inferred result type is\n                  // optional as well. Therefore we need to cast the toolResults to any.\n                  // The type exposed to the users will be correctly inferred.\n                  toolResults: stepToolResults as any,\n                  request: stepRequest,\n                  rawResponse,\n                  response: {\n                    ...stepResponse,\n                    headers: rawResponse?.headers,\n                    messages: responseMessages,\n                  },\n                  warnings,\n                  experimental_providerMetadata: stepProviderMetadata,\n                  steps: stepResults,\n                  responseMessages,\n                });\n              } catch (error) {\n                controller.error(error);\n              } finally {\n                rootSpan.end();\n              }\n            },\n          }),\n        ),\n      );\n    }\n\n    // add the initial stream to the stitchable stream\n    addStepStream({\n      stream,\n      startTimestamp: startTimestampMs,\n      doStreamSpan,\n      currentStep: 0,\n      responseMessages: [],\n      usage: undefined,\n      stepType: 'initial',\n      stepRequest: request,\n      hasLeadingWhitespace: false,\n    });\n  }\n\n  /**\nSplit out a new stream from the original stream.\nThe original stream is replaced to allow for further splitting,\nsince we do not know how many times the stream will be split.\n\nNote: this leads to buffering the stream content on the server.\nHowever, the LLM results are expected to be small enough to not cause issues.\n   */\n  private teeStream() {\n    const [stream1, stream2] = this.originalStream.tee();\n    this.originalStream = stream2;\n    return stream1;\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        if (chunk.type === 'text-delta') {\n          controller.enqueue(chunk.textDelta);\n        } else if (chunk.type === 'error') {\n          controller.error(chunk.error);\n        }\n      },\n    });\n  }\n\n  get fullStream(): AsyncIterableStream<TextStreamPart<TOOLS>> {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      },\n    });\n  }\n\n  toAIStream(callbacks: AIStreamCallbacksAndOptions = {}) {\n    return this.toDataStreamInternal({ callbacks });\n  }\n\n  private toDataStreamInternal({\n    callbacks = {},\n    getErrorMessage = () => '', // mask error messages for safety by default\n    sendUsage = true,\n  }: {\n    callbacks?: AIStreamCallbacksAndOptions;\n    getErrorMessage?: (error: unknown) => string;\n    sendUsage?: boolean;\n  } = {}) {\n    let aggregatedResponse = '';\n\n    const callbackTransformer = new TransformStream<\n      TextStreamPart<TOOLS>,\n      TextStreamPart<TOOLS>\n    >({\n      async start(): Promise<void> {\n        if (callbacks.onStart) await callbacks.onStart();\n      },\n\n      async transform(chunk, controller): Promise<void> {\n        controller.enqueue(chunk);\n\n        if (chunk.type === 'text-delta') {\n          const textDelta = chunk.textDelta;\n\n          aggregatedResponse += textDelta;\n\n          if (callbacks.onToken) await callbacks.onToken(textDelta);\n          if (callbacks.onText) await callbacks.onText(textDelta);\n        }\n      },\n\n      async flush(): Promise<void> {\n        if (callbacks.onCompletion)\n          await callbacks.onCompletion(aggregatedResponse);\n        if (callbacks.onFinal) await callbacks.onFinal(aggregatedResponse);\n      },\n    });\n\n    const streamPartsTransformer = new TransformStream<\n      TextStreamPart<TOOLS>,\n      string\n    >({\n      transform: async (chunk, controller) => {\n        const chunkType = chunk.type;\n        switch (chunkType) {\n          case 'text-delta': {\n            controller.enqueue(formatStreamPart('text', chunk.textDelta));\n            break;\n          }\n\n          case 'tool-call-streaming-start': {\n            controller.enqueue(\n              formatStreamPart('tool_call_streaming_start', {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n              }),\n            );\n            break;\n          }\n\n          case 'tool-call-delta': {\n            controller.enqueue(\n              formatStreamPart('tool_call_delta', {\n                toolCallId: chunk.toolCallId,\n                argsTextDelta: chunk.argsTextDelta,\n              }),\n            );\n            break;\n          }\n\n          case 'tool-call': {\n            controller.enqueue(\n              formatStreamPart('tool_call', {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                args: chunk.args,\n              }),\n            );\n            break;\n          }\n\n          case 'tool-result': {\n            controller.enqueue(\n              formatStreamPart('tool_result', {\n                toolCallId: chunk.toolCallId,\n                result: chunk.result,\n              }),\n            );\n            break;\n          }\n\n          case 'error': {\n            controller.enqueue(\n              formatStreamPart('error', getErrorMessage(chunk.error)),\n            );\n            break;\n          }\n\n          case 'step-finish': {\n            controller.enqueue(\n              formatStreamPart('finish_step', {\n                finishReason: chunk.finishReason,\n                usage: sendUsage\n                  ? {\n                      promptTokens: chunk.usage.promptTokens,\n                      completionTokens: chunk.usage.completionTokens,\n                    }\n                  : undefined,\n                isContinued: chunk.isContinued,\n              }),\n            );\n            break;\n          }\n\n          case 'finish': {\n            controller.enqueue(\n              formatStreamPart('finish_message', {\n                finishReason: chunk.finishReason,\n                usage: sendUsage\n                  ? {\n                      promptTokens: chunk.usage.promptTokens,\n                      completionTokens: chunk.usage.completionTokens,\n                    }\n                  : undefined,\n              }),\n            );\n            break;\n          }\n\n          default: {\n            const exhaustiveCheck: never = chunkType;\n            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n          }\n        }\n      },\n    });\n\n    return this.fullStream\n      .pipeThrough(callbackTransformer)\n      .pipeThrough(streamPartsTransformer)\n      .pipeThrough(new TextEncoderStream());\n  }\n\n  pipeAIStreamToResponse(\n    response: ServerResponse,\n    init?: { headers?: Record<string, string>; status?: number },\n  ): void {\n    return this.pipeDataStreamToResponse(response, init);\n  }\n\n  pipeDataStreamToResponse(\n    response: ServerResponse,\n    options?:\n      | ResponseInit\n      | {\n          init?: ResponseInit;\n          data?: StreamData;\n          getErrorMessage?: (error: unknown) => string;\n          sendUsage?: boolean;\n        },\n  ) {\n    const init: ResponseInit | undefined =\n      options == null\n        ? undefined\n        : 'init' in options\n        ? options.init\n        : {\n            headers: 'headers' in options ? options.headers : undefined,\n            status: 'status' in options ? options.status : undefined,\n            statusText:\n              'statusText' in options ? options.statusText : undefined,\n          };\n\n    const data: StreamData | undefined =\n      options == null\n        ? undefined\n        : 'data' in options\n        ? options.data\n        : undefined;\n\n    const getErrorMessage: ((error: unknown) => string) | undefined =\n      options == null\n        ? undefined\n        : 'getErrorMessage' in options\n        ? options.getErrorMessage\n        : undefined;\n\n    const sendUsage: boolean | undefined =\n      options == null\n        ? undefined\n        : 'sendUsage' in options\n        ? options.sendUsage\n        : undefined;\n\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init, {\n        contentType: 'text/plain; charset=utf-8',\n        dataStreamVersion: 'v1',\n      }),\n      stream: this.toDataStream({ data, getErrorMessage, sendUsage }),\n    });\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  toAIStreamResponse(\n    options?: ResponseInit | { init?: ResponseInit; data?: StreamData },\n  ): Response {\n    return this.toDataStreamResponse(options);\n  }\n\n  toDataStream(options?: {\n    data?: StreamData;\n    getErrorMessage?: (error: unknown) => string;\n    sendUsage?: boolean;\n  }) {\n    const stream = this.toDataStreamInternal({\n      getErrorMessage: options?.getErrorMessage,\n      sendUsage: options?.sendUsage,\n    });\n\n    return options?.data ? mergeStreams(options?.data.stream, stream) : stream;\n  }\n\n  toDataStreamResponse(\n    options?:\n      | ResponseInit\n      | {\n          init?: ResponseInit;\n          data?: StreamData;\n          getErrorMessage?: (error: unknown) => string;\n          sendUsage?: boolean;\n        },\n  ): Response {\n    const init: ResponseInit | undefined =\n      options == null\n        ? undefined\n        : 'init' in options\n        ? options.init\n        : {\n            headers: 'headers' in options ? options.headers : undefined,\n            status: 'status' in options ? options.status : undefined,\n            statusText:\n              'statusText' in options ? options.statusText : undefined,\n          };\n\n    const data: StreamData | undefined =\n      options == null\n        ? undefined\n        : 'data' in options\n        ? options.data\n        : undefined;\n\n    const getErrorMessage: ((error: unknown) => string) | undefined =\n      options == null\n        ? undefined\n        : 'getErrorMessage' in options\n        ? options.getErrorMessage\n        : undefined;\n\n    const sendUsage: boolean | undefined =\n      options == null\n        ? undefined\n        : 'sendUsage' in options\n        ? options.sendUsage\n        : undefined;\n\n    return new Response(\n      this.toDataStream({ data, getErrorMessage, sendUsage }),\n      {\n        status: init?.status ?? 200,\n        statusText: init?.statusText,\n        headers: prepareResponseHeaders(init, {\n          contentType: 'text/plain; charset=utf-8',\n          dataStreamVersion: 'v1',\n        }),\n      },\n    );\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n\n/**\n * @deprecated Use `streamText` instead.\n */\nexport const experimental_streamText = streamText;\n","/**\n * Creates a stitchable stream that can pipe one stream at a time.\n *\n * @template T - The type of values emitted by the streams.\n * @returns {Object} An object containing the stitchable stream and control methods.\n */\nexport function createStitchableStream<T>() {\n  let innerStreamReaders: ReadableStreamDefaultReader<T>[] = [];\n  let controller: ReadableStreamDefaultController<T> | null = null;\n  let isClosed = false;\n\n  const processPull = async () => {\n    // Case 1: Outer stream is closed and no more inner streams\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller?.close();\n      return;\n    }\n\n    // Case 2: No inner streams available, but outer stream is open\n    if (innerStreamReaders.length === 0) {\n      return;\n    }\n\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n\n      if (done) {\n        // Case 3: Current inner stream is done\n        innerStreamReaders.shift(); // Remove the finished stream\n\n        // Continue pulling from the next stream if available\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller?.close();\n        }\n      } else {\n        // Case 4: Current inner stream returns an item\n        controller?.enqueue(value);\n      }\n    } catch (error) {\n      // Case 5: Current inner stream throws an error\n      controller?.error(error);\n      innerStreamReaders.shift(); // Remove the errored stream\n\n      if (isClosed && innerStreamReaders.length === 0) {\n        controller?.close();\n      }\n    }\n  };\n\n  return {\n    stream: new ReadableStream<T>({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      },\n    }),\n    addStream: (innerStream: ReadableStream<T>) => {\n      if (isClosed) {\n        throw new Error('Cannot add inner stream: outer stream is closed');\n      }\n\n      innerStreamReaders.push(innerStream.getReader());\n    },\n    close: () => {\n      isClosed = true;\n\n      if (innerStreamReaders.length === 0) {\n        controller?.close();\n      }\n    },\n  };\n}\n","/**\n * Merges two readable streams into a single readable stream, emitting values\n * from each stream as they become available.\n *\n * The first stream is prioritized over the second stream. If both streams have\n * values available, the first stream's value is emitted first.\n *\n * @template VALUE1 - The type of values emitted by the first stream.\n * @template VALUE2 - The type of values emitted by the second stream.\n * @param {ReadableStream<VALUE1>} stream1 - The first readable stream.\n * @param {ReadableStream<VALUE2>} stream2 - The second readable stream.\n * @returns {ReadableStream<VALUE1 | VALUE2>} A new readable stream that emits values from both input streams.\n */\nexport function mergeStreams<VALUE1, VALUE2>(\n  stream1: ReadableStream<VALUE1>,\n  stream2: ReadableStream<VALUE2>,\n): ReadableStream<VALUE1 | VALUE2> {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n\n  let lastRead1: Promise<ReadableStreamReadResult<VALUE1>> | undefined =\n    undefined;\n  let lastRead2: Promise<ReadableStreamReadResult<VALUE2>> | undefined =\n    undefined;\n\n  let stream1Done = false;\n  let stream2Done = false;\n\n  // only use when stream 2 is done:\n  async function readStream1(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n\n      const result = await lastRead1;\n      lastRead1 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  // only use when stream 1 is done:\n  async function readStream2(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n\n      const result = await lastRead2;\n      lastRead2 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  return new ReadableStream<VALUE1 | VALUE2>({\n    async pull(controller) {\n      try {\n        // stream 1 is done, we can only read from stream 2:\n        if (stream1Done) {\n          await readStream2(controller);\n          return;\n        }\n\n        // stream 2 is done, we can only read from stream 1:\n        if (stream2Done) {\n          await readStream1(controller);\n          return;\n        }\n\n        // pull the next value from the stream that was read last:\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n\n        // Note on Promise.race (prioritizing stream 1 over stream 2):\n        // If the iterable contains one or more non-promise values and/or an already settled promise,\n        // then Promise.race() will settle to the first of these values found in the iterable.\n        const { result, reader } = await Promise.race([\n          lastRead1.then(result => ({ result, reader: reader1 })),\n          lastRead2.then(result => ({ result, reader: reader2 })),\n        ]);\n\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n\n        if (reader === reader1) {\n          lastRead1 = undefined;\n          if (result.done) {\n            // stream 1 is done, we can only read from stream 2:\n            await readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = undefined;\n          // stream 2 is done, we can only read from stream 1:\n          if (result.done) {\n            stream2Done = true;\n            await readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    },\n  });\n}\n","import { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport { generateId } from '@ai-sdk/ui-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { NoSuchToolError } from '../../errors/no-such-tool-error';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { CoreTool } from '../tool';\nimport {\n  FinishReason,\n  LanguageModelUsage,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { calculateLanguageModelUsage } from '../types/usage';\nimport { parseToolCall } from './parse-tool-call';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolResultUnion } from './tool-result';\n\nexport type SingleRequestTextStreamPart<\n  TOOLS extends Record<string, CoreTool>,\n> =\n  | {\n      type: 'text-delta';\n      textDelta: string;\n    }\n  | ({\n      type: 'tool-call';\n    } & ToolCallUnion<TOOLS>)\n  | {\n      type: 'tool-call-streaming-start';\n      toolCallId: string;\n      toolName: string;\n    }\n  | {\n      type: 'tool-call-delta';\n      toolCallId: string;\n      toolName: string;\n      argsTextDelta: string;\n    }\n  | ({\n      type: 'tool-result';\n    } & ToolResultUnion<TOOLS>)\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      logprobs?: LogProbs;\n      usage: LanguageModelUsage;\n      experimental_providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'error';\n      error: unknown;\n    };\n\nexport function runToolsTransformation<TOOLS extends Record<string, CoreTool>>({\n  tools,\n  generatorStream,\n  toolCallStreaming,\n  tracer,\n  telemetry,\n  abortSignal,\n}: {\n  tools: TOOLS | undefined;\n  generatorStream: ReadableStream<LanguageModelV1StreamPart>;\n  toolCallStreaming: boolean;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  abortSignal: AbortSignal | undefined;\n}): ReadableStream<SingleRequestTextStreamPart<TOOLS>> {\n  // tool results stream\n  let toolResultsStreamController: ReadableStreamDefaultController<\n    SingleRequestTextStreamPart<TOOLS>\n  > | null = null;\n  const toolResultsStream = new ReadableStream<\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    start(controller) {\n      toolResultsStreamController = controller;\n    },\n  });\n\n  // keep track of active tool calls for tool call streaming:\n  const activeToolCalls: Record<string, boolean> = {};\n\n  // keep track of outstanding tool results for stream closing:\n  const outstandingToolResults = new Set<string>();\n\n  let canClose = false;\n  let finishChunk:\n    | (SingleRequestTextStreamPart<TOOLS> & { type: 'finish' })\n    | undefined = undefined;\n\n  function attemptClose() {\n    // close the tool results controller if no more outstanding tool calls\n    if (canClose && outstandingToolResults.size === 0) {\n      // we delay sending the finish chunk until all tool results (incl. delayed ones)\n      // are received to ensure that the frontend receives tool results before a message\n      // finish event arrives.\n      if (finishChunk != null) {\n        toolResultsStreamController!.enqueue(finishChunk);\n      }\n\n      toolResultsStreamController!.close();\n    }\n  }\n\n  // forward stream\n  const forwardStream = new TransformStream<\n    LanguageModelV1StreamPart,\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    transform(\n      chunk: LanguageModelV1StreamPart,\n      controller: TransformStreamDefaultController<\n        SingleRequestTextStreamPart<TOOLS>\n      >,\n    ) {\n      const chunkType = chunk.type;\n\n      switch (chunkType) {\n        // forward:\n        case 'text-delta':\n        case 'response-metadata':\n        case 'error': {\n          controller.enqueue(chunk);\n          break;\n        }\n\n        // forward with less information:\n        case 'tool-call-delta': {\n          if (toolCallStreaming) {\n            if (!activeToolCalls[chunk.toolCallId]) {\n              controller.enqueue({\n                type: 'tool-call-streaming-start',\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n              });\n\n              activeToolCalls[chunk.toolCallId] = true;\n            }\n\n            controller.enqueue({\n              type: 'tool-call-delta',\n              toolCallId: chunk.toolCallId,\n              toolName: chunk.toolName,\n              argsTextDelta: chunk.argsTextDelta,\n            });\n          }\n          break;\n        }\n\n        // process tool call:\n        case 'tool-call': {\n          const toolName = chunk.toolName as keyof TOOLS & string;\n\n          if (tools == null) {\n            toolResultsStreamController!.enqueue({\n              type: 'error',\n              error: new NoSuchToolError({ toolName: chunk.toolName }),\n            });\n            break;\n          }\n\n          const tool = tools[toolName];\n\n          if (tool == null) {\n            toolResultsStreamController!.enqueue({\n              type: 'error',\n              error: new NoSuchToolError({\n                toolName: chunk.toolName,\n                availableTools: Object.keys(tools),\n              }),\n            });\n\n            break;\n          }\n\n          try {\n            const toolCall = parseToolCall({\n              toolCall: chunk,\n              tools,\n            });\n\n            controller.enqueue(toolCall);\n\n            if (tool.execute != null) {\n              const toolExecutionId = generateId(); // use our own id to guarantee uniqueness\n              outstandingToolResults.add(toolExecutionId);\n\n              // Note: we don't await the tool execution here (by leaving out 'await' on recordSpan),\n              // because we want to process the next chunk as soon as possible.\n              // This is important for the case where the tool execution takes a long time.\n              recordSpan({\n                name: 'ai.toolCall',\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: 'ai.toolCall',\n                      telemetry,\n                    }),\n                    'ai.toolCall.name': toolCall.toolName,\n                    'ai.toolCall.id': toolCall.toolCallId,\n                    'ai.toolCall.args': {\n                      output: () => JSON.stringify(toolCall.args),\n                    },\n                  },\n                }),\n                tracer,\n                fn: async span =>\n                  tool.execute!(toolCall.args, { abortSignal }).then(\n                    (result: any) => {\n                      toolResultsStreamController!.enqueue({\n                        ...toolCall,\n                        type: 'tool-result',\n                        result,\n                      } as any);\n\n                      outstandingToolResults.delete(toolExecutionId);\n\n                      attemptClose();\n\n                      // record telemetry\n                      try {\n                        span.setAttributes(\n                          selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                              'ai.toolCall.result': {\n                                output: () => JSON.stringify(result),\n                              },\n                            },\n                          }),\n                        );\n                      } catch (ignored) {\n                        // JSON stringify might fail if the result is not serializable,\n                        // in which case we just ignore it. In the future we might want to\n                        // add an optional serialize method to the tool interface and warn\n                        // if the result is not serializable.\n                      }\n                    },\n                    (error: any) => {\n                      toolResultsStreamController!.enqueue({\n                        type: 'error',\n                        error,\n                      });\n\n                      outstandingToolResults.delete(toolExecutionId);\n                      attemptClose();\n                    },\n                  ),\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController!.enqueue({\n              type: 'error',\n              error,\n            });\n          }\n\n          break;\n        }\n\n        case 'finish': {\n          finishChunk = {\n            type: 'finish',\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateLanguageModelUsage(chunk.usage),\n            experimental_providerMetadata: chunk.providerMetadata,\n          };\n          break;\n        }\n\n        default: {\n          const _exhaustiveCheck: never = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n\n    flush() {\n      canClose = true;\n      attemptClose();\n    },\n  });\n\n  // combine the generator stream and the tool results stream\n  return new ReadableStream<SingleRequestTextStreamPart<TOOLS>>({\n    async start(controller) {\n      // need to wait for both pipes so there are no dangling promises that\n      // can cause uncaught promise rejections when the stream is aborted\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              // the generator stream controller is automatically closed when it's consumed\n            },\n          }),\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            },\n          }),\n        ),\n      ]);\n    },\n  });\n}\n","import { LanguageModelV1, LanguageModelV1CallOptions } from '@ai-sdk/provider';\nimport { Experimental_LanguageModelV1Middleware } from './language-model-v1-middleware';\n\n/**\n * Wraps a LanguageModelV1 instance with middleware functionality.\n * This function allows you to apply middleware to transform parameters,\n * wrap generate operations, and wrap stream operations of a language model.\n *\n * @param options - Configuration options for wrapping the language model.\n * @param options.model - The original LanguageModelV1 instance to be wrapped.\n * @param options.middleware - The middleware to be applied to the language model.\n * @param options.modelId - Optional custom model ID to override the original model's ID.\n * @param options.providerId - Optional custom provider ID to override the original model's provider.\n * @returns A new LanguageModelV1 instance with middleware applied.\n */\nexport const experimental_wrapLanguageModel = ({\n  model,\n  middleware: { transformParams, wrapGenerate, wrapStream },\n  modelId,\n  providerId,\n}: {\n  model: LanguageModelV1;\n  middleware: Experimental_LanguageModelV1Middleware;\n  modelId?: string;\n  providerId?: string;\n}): LanguageModelV1 => {\n  async function doTransform({\n    params,\n    type,\n  }: {\n    params: LanguageModelV1CallOptions;\n    type: 'generate' | 'stream';\n  }) {\n    return transformParams ? await transformParams({ params, type }) : params;\n  }\n\n  return {\n    specificationVersion: 'v1',\n\n    provider: providerId ?? model.provider,\n    modelId: modelId ?? model.modelId,\n\n    defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n    supportsImageUrls: model.supportsImageUrls,\n    supportsUrl: model.supportsUrl,\n    supportsStructuredOutputs: model.supportsStructuredOutputs,\n\n    async doGenerate(\n      params: LanguageModelV1CallOptions,\n    ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n      const transformedParams = await doTransform({ params, type: 'generate' });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      return wrapGenerate\n        ? wrapGenerate({ doGenerate, params: transformedParams, model })\n        : doGenerate();\n    },\n\n    async doStream(\n      params: LanguageModelV1CallOptions,\n    ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n      const transformedParams = await doTransform({ params, type: 'stream' });\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream\n        ? wrapStream({ doStream, params: transformedParams, model })\n        : doStream();\n    },\n  };\n};\n","import { EmbeddingModelV1, LanguageModelV1 } from '@ai-sdk/provider';\nimport { Provider } from '../types';\nimport { NoSuchModelError } from '@ai-sdk/provider';\n\n/**\n * Creates a custom provider with specified language models, text embedding models, and an optional fallback provider.\n *\n * @param {Object} options - The options for creating the custom provider.\n * @param {Record<string, LanguageModelV1>} [options.languageModels] - A record of language models, where keys are model IDs and values are LanguageModelV1 instances.\n * @param {Record<string, EmbeddingModelV1<string>>} [options.textEmbeddingModels] - A record of text embedding models, where keys are model IDs and values are EmbeddingModelV1<string> instances.\n * @param {Provider} [options.fallbackProvider] - An optional fallback provider to use when a requested model is not found in the custom provider.\n * @returns {Provider} A Provider object with languageModel and textEmbeddingModel methods.\n *\n * @throws {NoSuchModelError} Throws when a requested model is not found and no fallback provider is available.\n */\nexport function experimental_customProvider({\n  languageModels,\n  textEmbeddingModels,\n  fallbackProvider,\n}: {\n  languageModels?: Record<string, LanguageModelV1>;\n  textEmbeddingModels?: Record<string, EmbeddingModelV1<string>>;\n  fallbackProvider?: Provider;\n}): Provider {\n  return {\n    languageModel(modelId: string): LanguageModelV1 {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'languageModel' });\n    },\n\n    textEmbeddingModel(modelId: string): EmbeddingModelV1<string> {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'textEmbeddingModel' });\n    },\n  };\n}\n","import { AISDKError, NoSuchModelError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchProviderError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchProviderError extends NoSuchModelError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly providerId: string;\n  readonly availableProviders: string[];\n\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`,\n  }: {\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel';\n    providerId: string;\n    availableProviders: string[];\n    message?: string;\n  }) {\n    super({ errorName: name, modelId, modelType, message });\n\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n\n  static isInstance(error: unknown): error is NoSuchProviderError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchProviderError(error: unknown): error is NoSuchProviderError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as NoSuchProviderError).providerId === 'string' &&\n      Array.isArray((error as NoSuchProviderError).availableProviders)\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      modelId: this.modelId,\n      modelType: this.modelType,\n\n      providerId: this.providerId,\n      availableProviders: this.availableProviders,\n    };\n  }\n}\n","import { NoSuchModelError } from '@ai-sdk/provider';\nimport { EmbeddingModel, LanguageModel, Provider } from '../types';\nimport { NoSuchProviderError } from './no-such-provider-error';\nimport { experimental_Provider } from './provider';\n\n/**\nRegistry for managing models. It enables getting a model with a string id.\n\n@deprecated Use `experimental_Provider` instead.\n */\nexport type experimental_ProviderRegistry = Provider;\n\n/**\n * @deprecated Use `experimental_ProviderRegistry` instead.\n */\nexport type experimental_ModelRegistry = experimental_ProviderRegistry;\n\n/**\n * Creates a registry for the given providers.\n */\nexport function experimental_createProviderRegistry(\n  providers: Record<string, experimental_Provider | Provider>,\n): Provider {\n  const registry = new DefaultProviderRegistry();\n\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n\n  return registry;\n}\n\n/**\n * @deprecated Use `experimental_createProviderRegistry` instead.\n */\nexport const experimental_createModelRegistry =\n  experimental_createProviderRegistry;\n\nclass DefaultProviderRegistry implements Provider {\n  private providers: Record<string, experimental_Provider | Provider> = {};\n\n  registerProvider({\n    id,\n    provider,\n  }: {\n    id: string;\n    provider: experimental_Provider | Provider;\n  }): void {\n    this.providers[id] = provider;\n  }\n\n  private getProvider(id: string): experimental_Provider | Provider {\n    const provider = this.providers[id];\n\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType: 'languageModel',\n        providerId: id,\n        availableProviders: Object.keys(this.providers),\n      });\n    }\n\n    return provider;\n  }\n\n  private splitId(\n    id: string,\n    modelType: 'languageModel' | 'textEmbeddingModel',\n  ): [string, string] {\n    const index = id.indexOf(':');\n\n    if (index === -1) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType,\n        message:\n          `Invalid ${modelType} id for registry: ${id} ` +\n          `(must be in the format \"providerId:modelId\")`,\n      });\n    }\n\n    return [id.slice(0, index), id.slice(index + 1)];\n  }\n\n  languageModel(id: string): LanguageModel {\n    const [providerId, modelId] = this.splitId(id, 'languageModel');\n    const model = this.getProvider(providerId).languageModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'languageModel' });\n    }\n\n    return model;\n  }\n\n  textEmbeddingModel(id: string): EmbeddingModel<string> {\n    const [providerId, modelId] = this.splitId(id, 'textEmbeddingModel');\n    const provider = this.getProvider(providerId);\n\n    const model =\n      provider.textEmbeddingModel?.(modelId) ??\n      ('textEmbedding' in provider\n        ? provider.textEmbedding?.(modelId)\n        : undefined);\n\n    if (model == null) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType: 'textEmbeddingModel',\n      });\n    }\n\n    return model;\n  }\n\n  /**\n   * @deprecated Use `textEmbeddingModel` instead.\n   */\n  textEmbedding(id: string): EmbeddingModel<string> {\n    return this.textEmbeddingModel(id);\n  }\n}\n","import { Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { ToolResultContent } from '../prompt/tool-result-content';\n\ntype Parameters = z.ZodTypeAny | Schema<any>;\n\nexport type inferParameters<PARAMETERS extends Parameters> =\n  PARAMETERS extends Schema<any>\n    ? PARAMETERS['_type']\n    : PARAMETERS extends z.ZodTypeAny\n    ? z.infer<PARAMETERS>\n    : never;\n\n/**\nA tool contains the description and the schema of the input that the tool expects.\nThis enables the language model to generate the input.\n\nThe tool can also contain an optional execute function for the actual execution function of the tool.\n */\nexport type CoreTool<PARAMETERS extends Parameters = any, RESULT = any> = {\n  /**\nThe schema of the input that the tool expects. The language model will use this to generate the input.\nIt is also used to validate the output of the language model.\nUse descriptions to make the input understandable for the language model.\n   */\n  parameters: PARAMETERS;\n\n  /**\nOptional conversion function that maps the tool result to multi-part tool content for LLMs.\n   */\n  experimental_toToolResultContent?: (result: RESULT) => ToolResultContent;\n\n  /**\nAn async function that is called with the arguments from the tool call and produces a result.\nIf not provided, the tool will not be executed automatically.\n\n@args is the input of the tool call.\n@options.abortSignal is a signal that can be used to abort the tool call.\n   */\n  execute?: (\n    args: inferParameters<PARAMETERS>,\n    options: { abortSignal?: AbortSignal },\n  ) => PromiseLike<RESULT>;\n} & (\n  | {\n      /**\nFunction tool.\n       */\n      type?: undefined | 'function';\n\n      /**\nAn optional description of what the tool does. Will be used by the language model to decide whether to use the tool.\n   */\n      description?: string;\n    }\n  | {\n      /**\nProvider-defined tool.\n       */\n      type: 'provider-defined';\n\n      /**\nThe ID of the tool. Should follow the format `<provider-name>.<tool-name>`.\n       */\n      id: `${string}.${string}`;\n\n      /**\nThe arguments for configuring the tool. Must match the expected arguments defined by the provider for this tool.\n       */\n      args: Record<string, unknown>;\n    }\n);\n\n/**\nHelper function for inferring the execute args of a tool.\n */\n// Note: special type inference is needed for the execute function args to make sure they are inferred correctly.\nexport function tool<PARAMETERS extends Parameters, RESULT>(\n  tool: CoreTool<PARAMETERS, RESULT> & {\n    execute: (\n      args: inferParameters<PARAMETERS>,\n      options: { abortSignal?: AbortSignal },\n    ) => PromiseLike<RESULT>;\n  },\n): CoreTool<PARAMETERS, RESULT> & {\n  execute: (\n    args: inferParameters<PARAMETERS>,\n    options: { abortSignal?: AbortSignal },\n  ) => PromiseLike<RESULT>;\n};\nexport function tool<PARAMETERS extends Parameters, RESULT>(\n  tool: CoreTool<PARAMETERS, RESULT> & {\n    execute?: undefined;\n  },\n): CoreTool<PARAMETERS, RESULT> & {\n  execute: undefined;\n};\nexport function tool<PARAMETERS extends Parameters, RESULT = any>(\n  tool: CoreTool<PARAMETERS, RESULT>,\n): CoreTool<PARAMETERS, RESULT> {\n  return tool;\n}\n\n/**\n * @deprecated Use `CoreTool` instead.\n */\nexport type ExperimentalTool = CoreTool;\n","/**\n * Calculates the cosine similarity between two vectors. This is a useful metric for\n * comparing the similarity of two vectors such as embeddings.\n *\n * @param vector1 - The first vector.\n * @param vector2 - The second vector.\n *\n * @returns The cosine similarity between vector1 and vector2.\n * @throws {Error} If the vectors do not have the same length.\n */\nexport function cosineSimilarity(vector1: number[], vector2: number[]) {\n  if (vector1.length !== vector2.length) {\n    throw new Error(\n      `Vectors must have the same length (vector1: ${vector1.length} elements, vector2: ${vector2.length} elements)`,\n    );\n  }\n\n  return (\n    dotProduct(vector1, vector2) / (magnitude(vector1) * magnitude(vector2))\n  );\n}\n\n/**\n * Calculates the dot product of two vectors.\n * @param vector1 - The first vector.\n * @param vector2 - The second vector.\n * @returns The dot product of vector1 and vector2.\n */\nfunction dotProduct(vector1: number[], vector2: number[]) {\n  return vector1.reduce(\n    (accumulator: number, value: number, index: number) =>\n      accumulator + value * vector2[index]!,\n    0,\n  );\n}\n\n/**\n * Calculates the magnitude of a vector.\n * @param vector - The vector.\n * @returns The magnitude of the vector.\n */\nfunction magnitude(vector: number[]) {\n  return Math.sqrt(dotProduct(vector, vector));\n}\n","import {\n  createParser,\n  type EventSourceParser,\n  type ParsedEvent,\n  type ReconnectInterval,\n} from 'eventsource-parser';\nimport { OpenAIStreamCallbacks } from './openai-stream';\n\nexport interface FunctionCallPayload {\n  name: string;\n  arguments: Record<string, unknown>;\n}\nexport interface ToolCallPayload {\n  tools: {\n    id: string;\n    type: 'function';\n    func: {\n      name: string;\n      arguments: Record<string, unknown>;\n    };\n  }[];\n}\n\n/**\n * Configuration options and helper callback methods for AIStream stream lifecycle events.\n * @interface\n */\nexport interface AIStreamCallbacksAndOptions {\n  /** `onStart`: Called once when the stream is initialized. */\n  onStart?: () => Promise<void> | void;\n  /** `onCompletion`: Called for each tokenized message. */\n  onCompletion?: (completion: string) => Promise<void> | void;\n  /** `onFinal`: Called once when the stream is closed with the final completion message. */\n  onFinal?: (completion: string) => Promise<void> | void;\n  /** `onToken`: Called for each tokenized message. */\n  onToken?: (token: string) => Promise<void> | void;\n  /** `onText`: Called for each text chunk. */\n  onText?: (text: string) => Promise<void> | void;\n  /**\n   * @deprecated This flag is no longer used and only retained for backwards compatibility.\n   * You can remove it from your code.\n   */\n  experimental_streamData?: boolean;\n}\n\n/**\n * Options for the AIStreamParser.\n * @interface\n * @property {string} event - The event (type) from the server side event stream.\n */\nexport interface AIStreamParserOptions {\n  event?: string;\n}\n\n/**\n * Custom parser for AIStream data.\n * @interface\n * @param {string} data - The data to be parsed.\n * @param {AIStreamParserOptions} options - The options for the parser.\n * @returns {string | void} The parsed data or void.\n */\nexport interface AIStreamParser {\n  (data: string, options: AIStreamParserOptions):\n    | string\n    | void\n    | { isText: false; content: string };\n}\n\n/**\n * Creates a TransformStream that parses events from an EventSource stream using a custom parser.\n * @param {AIStreamParser} customParser - Function to handle event data.\n * @returns {TransformStream<Uint8Array, string>} TransformStream parsing events.\n */\nexport function createEventStreamTransformer(\n  customParser?: AIStreamParser,\n): TransformStream<Uint8Array, string | { isText: false; content: string }> {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser: EventSourceParser;\n\n  return new TransformStream({\n    async start(controller): Promise<void> {\n      eventSourceParser = createParser(\n        (event: ParsedEvent | ReconnectInterval) => {\n          if (\n            ('data' in event &&\n              event.type === 'event' &&\n              event.data === '[DONE]') ||\n            // Replicate doesn't send [DONE] but does send a 'done' event\n            // @see https://replicate.com/docs/streaming\n            (event as any).event === 'done'\n          ) {\n            controller.terminate();\n            return;\n          }\n\n          if ('data' in event) {\n            const parsedMessage = customParser\n              ? customParser(event.data, {\n                  event: event.event,\n                })\n              : event.data;\n            if (parsedMessage) controller.enqueue(parsedMessage);\n          }\n        },\n      );\n    },\n\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    },\n  });\n}\n\n/**\n * Creates a transform stream that encodes input messages and invokes optional callback functions.\n * The transform stream uses the provided callbacks to execute custom logic at different stages of the stream's lifecycle.\n * - `onStart`: Called once when the stream is initialized.\n * - `onToken`: Called for each tokenized message.\n * - `onCompletion`: Called every time an AIStream completion message is received. This can occur multiple times when using e.g. OpenAI functions\n * - `onFinal`: Called once when the stream is closed with the final completion message.\n *\n * This function is useful when you want to process a stream of messages and perform specific actions during the stream's lifecycle.\n *\n * @param {AIStreamCallbacksAndOptions} [callbacks] - An object containing the callback functions.\n * @return {TransformStream<string, Uint8Array>} A transform stream that encodes input messages as Uint8Array and allows the execution of custom logic through callbacks.\n *\n * @example\n * const callbacks = {\n *   onStart: async () => console.log('Stream started'),\n *   onToken: async (token) => console.log(`Token: ${token}`),\n *   onCompletion: async (completion) => console.log(`Completion: ${completion}`)\n *   onFinal: async () => data.close()\n * };\n * const transformer = createCallbacksTransformer(callbacks);\n */\nexport function createCallbacksTransformer(\n  cb: AIStreamCallbacksAndOptions | OpenAIStreamCallbacks | undefined,\n): TransformStream<string | { isText: false; content: string }, Uint8Array> {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = '';\n  const callbacks = cb || {};\n\n  return new TransformStream({\n    async start(): Promise<void> {\n      if (callbacks.onStart) await callbacks.onStart();\n    },\n\n    async transform(message, controller): Promise<void> {\n      const content = typeof message === 'string' ? message : message.content;\n\n      controller.enqueue(textEncoder.encode(content));\n\n      aggregatedResponse += content;\n\n      if (callbacks.onToken) await callbacks.onToken(content);\n      if (callbacks.onText && typeof message === 'string') {\n        await callbacks.onText(message);\n      }\n    },\n\n    async flush(): Promise<void> {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      // If it's OpenAICallbacks, it has an experimental_onFunctionCall which means that the createFunctionCallTransformer\n      // will handle calling onComplete.\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    },\n  });\n}\n\nfunction isOfTypeOpenAIStreamCallbacks(\n  callbacks: AIStreamCallbacksAndOptions | OpenAIStreamCallbacks,\n): callbacks is OpenAIStreamCallbacks {\n  return 'experimental_onFunctionCall' in callbacks;\n}\n/**\n * Returns a stateful function that, when invoked, trims leading whitespace\n * from the input text. The trimming only occurs on the first invocation, ensuring that\n * subsequent calls do not alter the input text. This is particularly useful in scenarios\n * where a text stream is being processed and only the initial whitespace should be removed.\n *\n * @return {function(string): string} A function that takes a string as input and returns a string\n * with leading whitespace removed if it is the first invocation; otherwise, it returns the input unchanged.\n *\n * @example\n * const trimStart = trimStartOfStreamHelper();\n * const output1 = trimStart(\"   text\"); // \"text\"\n * const output2 = trimStart(\"   text\"); // \"   text\"\n *\n */\nexport function trimStartOfStreamHelper(): (text: string) => string {\n  let isStreamStart = true;\n\n  return (text: string): string => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text) isStreamStart = false;\n    }\n    return text;\n  };\n}\n\n/**\n * Returns a ReadableStream created from the response, parsed and handled with custom logic.\n * The stream goes through two transformation stages, first parsing the events and then\n * invoking the provided callbacks.\n *\n * For 2xx HTTP responses:\n * - The function continues with standard stream processing.\n *\n * For non-2xx HTTP responses:\n * - If the response body is defined, it asynchronously extracts and decodes the response body.\n * - It then creates a custom ReadableStream to propagate a detailed error message.\n *\n * @param {Response} response - The response.\n * @param {AIStreamParser} customParser - The custom parser function.\n * @param {AIStreamCallbacksAndOptions} callbacks - The callbacks.\n * @return {ReadableStream} The AIStream.\n * @throws Will throw an error if the response is not OK.\n */\nexport function AIStream(\n  response: Response,\n  customParser?: AIStreamParser,\n  callbacks?: AIStreamCallbacksAndOptions,\n): ReadableStream<Uint8Array> {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        },\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error('Response error: No response body'));\n        },\n      });\n    }\n  }\n\n  const responseBodyStream = response.body || createEmptyReadableStream();\n\n  return responseBodyStream\n    .pipeThrough(createEventStreamTransformer(customParser))\n    .pipeThrough(createCallbacksTransformer(callbacks));\n}\n\n// outputs lines like\n// 0: chunk\n// 0: more chunk\n// 1: a fct call\n// z: added data from Data\n\n/**\n * Creates an empty ReadableStream that immediately closes upon creation.\n * This function is used as a fallback for creating a ReadableStream when the response body is null or undefined,\n * ensuring that the subsequent pipeline processing doesn't fail due to a lack of a stream.\n *\n * @returns {ReadableStream} An empty and closed ReadableStream instance.\n */\nfunction createEmptyReadableStream(): ReadableStream {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    },\n  });\n}\n\n/**\n * Implements ReadableStream.from(asyncIterable), which isn't documented in MDN and isn't implemented in node.\n * https://github.com/whatwg/streams/commit/8d7a0bf26eb2cc23e884ddbaac7c1da4b91cf2bc\n */\nexport function readableFromAsyncIterable<T>(iterable: AsyncIterable<T>) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream<T>({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done) controller.close();\n      else controller.enqueue(value);\n    },\n\n    async cancel(reason) {\n      await it.return?.(reason);\n    },\n  });\n}\n","import { JSONValue, formatStreamPart } from '@ai-sdk/ui-utils';\nimport { HANGING_STREAM_WARNING_TIME_MS } from '../util/constants';\n\n/**\n * A stream wrapper to send custom JSON-encoded data back to the client.\n */\nexport class StreamData {\n  private encoder = new TextEncoder();\n\n  private controller: ReadableStreamController<Uint8Array> | null = null;\n  public stream: ReadableStream<Uint8Array>;\n\n  private isClosed: boolean = false;\n  private warningTimeout: NodeJS.Timeout | null = null;\n\n  constructor() {\n    const self = this;\n\n    this.stream = new ReadableStream({\n      start: async controller => {\n        self.controller = controller;\n\n        // Set a timeout to show a warning if the stream is not closed within 3 seconds\n        if (process.env.NODE_ENV === 'development') {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              'The data stream is hanging. Did you forget to close it with `data.close()`?',\n            );\n          }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n      },\n      pull: controller => {\n        // No-op: we don't need to do anything special on pull\n      },\n      cancel: reason => {\n        this.isClosed = true;\n      },\n    });\n  }\n\n  async close(): Promise<void> {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.close();\n    this.isClosed = true;\n\n    // Clear the warning timeout if the stream is closed\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n\n  append(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatStreamPart('data', [value])),\n    );\n  }\n\n  appendMessageAnnotation(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatStreamPart('message_annotations', [value])),\n    );\n  }\n}\n\n/**\n * A TransformStream for LLMs that do not have their own transform stream handlers managing encoding (e.g. OpenAIStream has one for function call handling).\n * This assumes every chunk is a 'text' chunk.\n */\nexport function createStreamDataTransformer() {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode(formatStreamPart('text', message)));\n    },\n  });\n}\n\n/**\n@deprecated Use `StreamData` instead.\n */\nexport class experimental_StreamData extends StreamData {}\n","/**\n * Warning time for notifying developers that a stream is hanging in dev mode\n * using a console.warn.\n */\nexport const HANGING_STREAM_WARNING_TIME_MS = 15 * 1000;\n","import {\n  AIStream,\n  readableFromAsyncIterable,\n  type AIStreamCallbacksAndOptions,\n  createCallbacksTransformer,\n} from './ai-stream';\nimport { createStreamDataTransformer } from './stream-data';\n\n// from anthropic sdk (Completion)\ninterface CompletionChunk {\n  /**\n   * Unique object identifier.\n   *\n   * The format and length of IDs may change over time.\n   */\n  id: string;\n\n  /**\n   * The resulting completion up to and excluding the stop sequences.\n   */\n  completion: string;\n\n  /**\n   * The model that handled the request.\n   */\n  model: string;\n\n  /**\n   * The reason that we stopped.\n   *\n   * This may be one the following values:\n   *\n   * - `\"stop_sequence\"`: we reached a stop sequence  either provided by you via the\n   *   `stop_sequences` parameter, or a stop sequence built into the model\n   * - `\"max_tokens\"`: we exceeded `max_tokens_to_sample` or the model's maximum\n   */\n  stop_reason: string | null;\n\n  /**\n   * Object type.\n   *\n   * For Text Completions, this is always `\"completion\"`.\n   */\n  type: 'completion';\n}\n\ninterface StreamError {\n  error: {\n    type: string;\n    message: string;\n  };\n}\n\ninterface StreamPing {}\n\ntype StreamData = CompletionChunk | StreamError | StreamPing;\n\ninterface Message {\n  id: string;\n  content: Array<ContentBlock>;\n  model: string;\n  role: 'assistant';\n  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | null;\n  stop_sequence: string | null;\n  type: 'message';\n}\n\ninterface ContentBlock {\n  text: string;\n  type: 'text';\n}\n\ninterface TextDelta {\n  text: string;\n  type: 'text_delta';\n}\n\ninterface ContentBlockDeltaEvent {\n  delta: TextDelta;\n  index: number;\n  type: 'content_block_delta';\n}\n\ninterface ContentBlockStartEvent {\n  content_block: ContentBlock;\n  index: number;\n  type: 'content_block_start';\n}\n\ninterface ContentBlockStopEvent {\n  index: number;\n  type: 'content_block_stop';\n}\n\ninterface MessageDeltaEventDelta {\n  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | null;\n  stop_sequence: string | null;\n}\n\ninterface MessageDeltaEvent {\n  delta: MessageDeltaEventDelta;\n  type: 'message_delta';\n}\n\ntype MessageStreamEvent =\n  | MessageStartEvent\n  | MessageDeltaEvent\n  | MessageStopEvent\n  | ContentBlockStartEvent\n  | ContentBlockDeltaEvent\n  | ContentBlockStopEvent;\n\ninterface MessageStartEvent {\n  message: Message;\n  type: 'message_start';\n}\n\ninterface MessageStopEvent {\n  type: 'message_stop';\n}\n\nfunction parseAnthropicStream(): (data: string) => string | void {\n  let previous = '';\n\n  return data => {\n    const json = JSON.parse(data as string) as StreamData;\n\n    // error event\n    if ('error' in json) {\n      throw new Error(`${json.error.type}: ${json.error.message}`);\n    }\n\n    // ping event\n    if (!('completion' in json)) {\n      return;\n    }\n\n    // On API versions older than 2023-06-01,\n    // Anthropic's `completion` field is cumulative unlike OpenAI's\n    // deltas. In order to compute the delta, we must slice out the text\n    // we previously received.\n    const text = json.completion;\n    if (\n      !previous ||\n      (text.length > previous.length && text.startsWith(previous))\n    ) {\n      const delta = text.slice(previous.length);\n      previous = text;\n\n      return delta;\n    }\n\n    return text;\n  };\n}\n\nasync function* streamable(\n  stream: AsyncIterable<CompletionChunk> | AsyncIterable<MessageStreamEvent>,\n) {\n  for await (const chunk of stream) {\n    if ('completion' in chunk) {\n      // completion stream\n      const text = chunk.completion;\n      if (text) yield text;\n    } else if ('delta' in chunk) {\n      // messge stream\n      const { delta } = chunk;\n      if ('text' in delta) {\n        const text = delta.text;\n        if (text) yield text;\n      }\n    }\n  }\n}\n\n/**\n * Accepts either a fetch Response from the Anthropic `POST /v1/complete` endpoint,\n * or the return value of `await client.completions.create({ stream: true })`\n * from the `@anthropic-ai/sdk` package.\n *\n * @deprecated Use the [Anthropic provider](https://sdk.vercel.ai/providers/ai-sdk-providers/anthropic) instead.\n */\nexport function AnthropicStream(\n  res:\n    | Response\n    | AsyncIterable<CompletionChunk>\n    | AsyncIterable<MessageStreamEvent>,\n  cb?: AIStreamCallbacksAndOptions,\n): ReadableStream {\n  if (Symbol.asyncIterator in res) {\n    return readableFromAsyncIterable(streamable(res))\n      .pipeThrough(createCallbacksTransformer(cb))\n      .pipeThrough(createStreamDataTransformer());\n  } else {\n    return AIStream(res, parseAnthropicStream(), cb).pipeThrough(\n      createStreamDataTransformer(),\n    );\n  }\n}\n","import {\n  AssistantMessage,\n  DataMessage,\n  formatStreamPart,\n} from '@ai-sdk/ui-utils';\nimport type { AssistantStream } from 'openai/lib/AssistantStream';\nimport type { Run } from 'openai/resources/beta/threads/runs/runs';\n\n/**\nYou can pass the thread and the latest message into the `AssistantResponse`. This establishes the context for the response.\n */\ntype AssistantResponseSettings = {\n  /**\nThe thread ID that the response is associated with.\n   */\n  threadId: string;\n\n  /**\nThe ID of the latest message that the response is associated with.\n */\n  messageId: string;\n};\n\n/**\nThe process parameter is a callback in which you can run the assistant on threads, and send messages and data messages to the client.\n */\ntype AssistantResponseCallback = (options: {\n  /**\n@deprecated use variable from outer scope instead.\n   */\n  threadId: string;\n\n  /**\n@deprecated use variable from outer scope instead.\n   */\n  messageId: string;\n\n  /**\nForwards an assistant message (non-streaming) to the client.\n   */\n  sendMessage: (message: AssistantMessage) => void;\n\n  /**\nSend a data message to the client. You can use this to provide information for rendering custom UIs while the assistant is processing the thread.\n */\n  sendDataMessage: (message: DataMessage) => void;\n\n  /**\nForwards the assistant response stream to the client. Returns the `Run` object after it completes, or when it requires an action.\n   */\n  forwardStream: (stream: AssistantStream) => Promise<Run | undefined>;\n}) => Promise<void>;\n\n/**\nThe `AssistantResponse` allows you to send a stream of assistant update to `useAssistant`.\nIt is designed to facilitate streaming assistant responses to the `useAssistant` hook.\nIt receives an assistant thread and a current message, and can send messages and data messages to the client.\n */\nexport function AssistantResponse(\n  { threadId, messageId }: AssistantResponseSettings,\n  process: AssistantResponseCallback,\n): Response {\n  const stream = new ReadableStream({\n    async start(controller) {\n      const textEncoder = new TextEncoder();\n\n      const sendMessage = (message: AssistantMessage) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart('assistant_message', message)),\n        );\n      };\n\n      const sendDataMessage = (message: DataMessage) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart('data_message', message)),\n        );\n      };\n\n      const sendError = (errorMessage: string) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart('error', errorMessage)),\n        );\n      };\n\n      const forwardStream = async (stream: AssistantStream) => {\n        let result: Run | undefined = undefined;\n\n        for await (const value of stream) {\n          switch (value.event) {\n            case 'thread.message.created': {\n              controller.enqueue(\n                textEncoder.encode(\n                  formatStreamPart('assistant_message', {\n                    id: value.data.id,\n                    role: 'assistant',\n                    content: [{ type: 'text', text: { value: '' } }],\n                  }),\n                ),\n              );\n              break;\n            }\n\n            case 'thread.message.delta': {\n              const content = value.data.delta.content?.[0];\n\n              if (content?.type === 'text' && content.text?.value != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    formatStreamPart('text', content.text.value),\n                  ),\n                );\n              }\n\n              break;\n            }\n\n            case 'thread.run.completed':\n            case 'thread.run.requires_action': {\n              result = value.data;\n              break;\n            }\n          }\n        }\n\n        return result;\n      };\n\n      // send the threadId and messageId as the first message:\n      controller.enqueue(\n        textEncoder.encode(\n          formatStreamPart('assistant_control_data', {\n            threadId,\n            messageId,\n          }),\n        ),\n      );\n\n      try {\n        await process({\n          threadId,\n          messageId,\n          sendMessage,\n          sendDataMessage,\n          forwardStream,\n        });\n      } catch (error) {\n        sendError((error as any).message ?? `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {},\n    cancel() {},\n  });\n\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      'Content-Type': 'text/plain; charset=utf-8',\n    },\n  });\n}\n\n/**\n@deprecated Use `AssistantResponse` instead.\n */\nexport const experimental_AssistantResponse = AssistantResponse;\n","import {\n  AIStreamCallbacksAndOptions,\n  createCallbacksTransformer,\n  readableFromAsyncIterable,\n} from './ai-stream';\nimport { createStreamDataTransformer } from './stream-data';\n\ninterface AWSBedrockResponse {\n  body?: AsyncIterable<{\n    chunk?: { bytes?: Uint8Array };\n  }>;\n}\n\nasync function* asDeltaIterable(\n  response: AWSBedrockResponse,\n  extractTextDeltaFromChunk: (chunk: any) => string,\n) {\n  const decoder = new TextDecoder();\n  for await (const chunk of response.body ?? []) {\n    const bytes = chunk.chunk?.bytes;\n\n    if (bytes != null) {\n      const chunkText = decoder.decode(bytes);\n      const chunkJSON = JSON.parse(chunkText);\n      const delta = extractTextDeltaFromChunk(chunkJSON);\n\n      if (delta != null) {\n        yield delta;\n      }\n    }\n  }\n}\n\nexport function AWSBedrockAnthropicMessagesStream(\n  response: AWSBedrockResponse,\n  callbacks?: AIStreamCallbacksAndOptions,\n): ReadableStream {\n  return AWSBedrockStream(response, callbacks, chunk => chunk.delta?.text);\n}\n\nexport function AWSBedrockAnthropicStream(\n  response: AWSBedrockResponse,\n  callbacks?: AIStreamCallbacksAndOptions,\n): ReadableStream {\n  return AWSBedrockStream(response, callbacks, chunk => chunk.completion);\n}\n\nexport function AWSBedrockCohereStream(\n  response: AWSBedrockResponse,\n  callbacks?: AIStreamCallbacksAndOptions,\n): ReadableStream {\n  return AWSBedrockStream(response, callbacks, chunk => chunk?.text);\n}\n\nexport function AWSBedrockLlama2Stream(\n  response: AWSBedrockResponse,\n  callbacks?: AIStreamCallbacksAndOptions,\n): ReadableStream {\n  return AWSBedrockStream(response, callbacks, chunk => chunk.generation);\n}\n\nexport function AWSBedrockStream(\n  response: AWSBedrockResponse,\n  callbacks: AIStreamCallbacksAndOptions | undefined,\n  extractTextDeltaFromChunk: (chunk: any) => string,\n) {\n  return readableFromAsyncIterable(\n    asDeltaIterable(response, extractTextDeltaFromChunk),\n  )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(createStreamDataTransformer());\n}\n","import {\n  type AIStreamCallbacksAndOptions,\n  createCallbacksTransformer,\n  readableFromAsyncIterable,\n} from './ai-stream';\nimport { createStreamDataTransformer } from './stream-data';\n\nconst utf8Decoder = new TextDecoder('utf-8');\n\n// Full types\n// @see: https://github.com/cohere-ai/cohere-typescript/blob/c2eceb4a845098240ba0bc44e3787ccf75e268e8/src/api/types/StreamedChatResponse.ts\ninterface StreamChunk {\n  text?: string;\n  eventType:\n    | 'stream-start'\n    | 'search-queries-generation'\n    | 'search-results'\n    | 'text-generation'\n    | 'citation-generation'\n    | 'stream-end';\n}\n\nasync function processLines(\n  lines: string[],\n  controller: ReadableStreamDefaultController<string>,\n) {\n  for (const line of lines) {\n    const { text, is_finished } = JSON.parse(line);\n\n    // closing the reader is handed in readAndProcessLines\n    if (!is_finished) {\n      controller.enqueue(text);\n    }\n  }\n}\n\nasync function readAndProcessLines(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  controller: ReadableStreamDefaultController<string>,\n) {\n  let segment = '';\n\n  while (true) {\n    const { value: chunk, done } = await reader.read();\n    if (done) {\n      break;\n    }\n\n    segment += utf8Decoder.decode(chunk, { stream: true });\n\n    const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n    segment = linesArray.pop() || '';\n\n    await processLines(linesArray, controller);\n  }\n\n  if (segment) {\n    const linesArray = [segment];\n    await processLines(linesArray, controller);\n  }\n\n  controller.close();\n}\n\nfunction createParser(res: Response) {\n  const reader = res.body?.getReader();\n\n  return new ReadableStream<string>({\n    async start(controller): Promise<void> {\n      if (!reader) {\n        controller.close();\n        return;\n      }\n\n      await readAndProcessLines(reader, controller);\n    },\n  });\n}\n\nasync function* streamable(stream: AsyncIterable<StreamChunk>) {\n  for await (const chunk of stream) {\n    if (chunk.eventType === 'text-generation') {\n      const text = chunk.text;\n      if (text) yield text;\n    }\n  }\n}\n\nexport function CohereStream(\n  reader: Response | AsyncIterable<StreamChunk>,\n  callbacks?: AIStreamCallbacksAndOptions,\n): ReadableStream {\n  if (Symbol.asyncIterator in reader) {\n    return readableFromAsyncIterable(streamable(reader))\n      .pipeThrough(createCallbacksTransformer(callbacks))\n      .pipeThrough(createStreamDataTransformer());\n  } else {\n    return createParser(reader)\n      .pipeThrough(createCallbacksTransformer(callbacks))\n      .pipeThrough(createStreamDataTransformer());\n  }\n}\n","import {\n  createCallbacksTransformer,\n  readableFromAsyncIterable,\n  type AIStreamCallbacksAndOptions,\n} from './ai-stream';\nimport { createStreamDataTransformer } from './stream-data';\n\ninterface GenerateContentResponse {\n  candidates?: GenerateContentCandidate[];\n}\n\ninterface GenerateContentCandidate {\n  index: number;\n  content: Content;\n}\n\ninterface Content {\n  role: string;\n  parts: Part[];\n}\n\ntype Part = TextPart | InlineDataPart;\n\ninterface InlineDataPart {\n  text?: never;\n}\n\ninterface TextPart {\n  text: string;\n  inlineData?: never;\n}\n\nasync function* streamable(response: {\n  stream: AsyncIterable<GenerateContentResponse>;\n}) {\n  for await (const chunk of response.stream) {\n    const parts = chunk.candidates?.[0]?.content?.parts;\n\n    if (parts === undefined) {\n      continue;\n    }\n\n    const firstPart = parts[0];\n\n    if (typeof firstPart.text === 'string') {\n      yield firstPart.text;\n    }\n  }\n}\n\n/**\n * @deprecated Use the [Google Generative AI provider](https://sdk.vercel.ai/providers/ai-sdk-providers/google-generative-ai) instead.\n */\nexport function GoogleGenerativeAIStream(\n  response: {\n    stream: AsyncIterable<GenerateContentResponse>;\n  },\n  cb?: AIStreamCallbacksAndOptions,\n): ReadableStream {\n  return readableFromAsyncIterable(streamable(response))\n    .pipeThrough(createCallbacksTransformer(cb))\n    .pipeThrough(createStreamDataTransformer());\n}\n","import {\n  type AIStreamCallbacksAndOptions,\n  createCallbacksTransformer,\n  trimStartOfStreamHelper,\n} from './ai-stream';\nimport { createStreamDataTransformer } from './stream-data';\n\nfunction createParser(res: AsyncGenerator<any>) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream<string>({\n    async pull(controller): Promise<void> {\n      const { value, done } = await res.next();\n\n      if (done) {\n        controller.close();\n        return;\n      }\n\n      const text = trimStartOfStream(value.token?.text ?? '');\n      if (!text) return;\n\n      // some HF models return generated_text instead of a real ending token\n      if (value.generated_text != null && value.generated_text.length > 0) {\n        return;\n      }\n\n      // <|endoftext|> is for https://huggingface.co/OpenAssistant/oasst-sft-4-pythia-12b-epoch-3.5\n      // <|end|> is for https://huggingface.co/HuggingFaceH4/starchat-beta\n      // </s> is also often last token in the stream depending on the model\n      if (text === '</s>' || text === '<|endoftext|>' || text === '<|end|>') {\n        return;\n      }\n\n      controller.enqueue(text);\n    },\n  });\n}\n\nexport function HuggingFaceStream(\n  res: AsyncGenerator<any>,\n  callbacks?: AIStreamCallbacksAndOptions,\n): ReadableStream {\n  return createParser(res)\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(createStreamDataTransformer());\n}\n","// packages/ai/streams/inkeep-stream.ts\nimport {\n  AIStream,\n  type AIStreamCallbacksAndOptions,\n  AIStreamParser,\n} from './ai-stream';\nimport { createStreamDataTransformer } from './stream-data';\n\nexport type InkeepOnFinalMetadata = {\n  chat_session_id: string;\n  records_cited: any;\n};\n\nexport type InkeepChatResultCallbacks = {\n  onFinal?: (\n    completion: string,\n    metadata?: InkeepOnFinalMetadata,\n  ) => Promise<void> | void;\n  onRecordsCited?: (\n    records_cited: InkeepOnFinalMetadata['records_cited'],\n  ) => void;\n};\n\nexport type InkeepAIStreamCallbacksAndOptions = AIStreamCallbacksAndOptions &\n  InkeepChatResultCallbacks;\n\nexport function InkeepStream(\n  res: Response,\n  callbacks?: InkeepAIStreamCallbacksAndOptions,\n): ReadableStream {\n  if (!res.body) {\n    throw new Error('Response body is null');\n  }\n\n  let chat_session_id = '';\n  let records_cited: any;\n\n  const inkeepEventParser: AIStreamParser = (data: string, options) => {\n    const { event } = options;\n\n    if (event === 'records_cited') {\n      records_cited = JSON.parse(data) as any;\n      callbacks?.onRecordsCited?.(records_cited);\n    }\n\n    if (event === 'message_chunk') {\n      const inkeepMessageChunk = JSON.parse(data);\n      chat_session_id = inkeepMessageChunk.chat_session_id ?? chat_session_id;\n      return inkeepMessageChunk.content_chunk;\n    }\n    return;\n  };\n\n  let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n\n  // extend onFinal callback with Inkeep specific metadata\n  passThroughCallbacks = {\n    ...passThroughCallbacks,\n    onFinal: completion => {\n      const inkeepOnFinalMetadata: InkeepOnFinalMetadata = {\n        chat_session_id,\n        records_cited,\n      };\n      callbacks?.onFinal?.(completion, inkeepOnFinalMetadata);\n    },\n  };\n\n  return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(\n    createStreamDataTransformer(),\n  );\n}\n","import { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport {\n  AIStreamCallbacksAndOptions,\n  createCallbacksTransformer,\n} from './ai-stream';\nimport { createStreamDataTransformer, StreamData } from './stream-data';\n\ntype LangChainImageDetail = 'auto' | 'low' | 'high';\n\ntype LangChainMessageContentText = {\n  type: 'text';\n  text: string;\n};\n\ntype LangChainMessageContentImageUrl = {\n  type: 'image_url';\n  image_url:\n    | string\n    | {\n        url: string;\n        detail?: LangChainImageDetail;\n      };\n};\n\ntype LangChainMessageContentComplex =\n  | LangChainMessageContentText\n  | LangChainMessageContentImageUrl\n  | (Record<string, any> & {\n      type?: 'text' | 'image_url' | string;\n    })\n  | (Record<string, any> & {\n      type?: never;\n    });\n\ntype LangChainMessageContent = string | LangChainMessageContentComplex[];\n\ntype LangChainAIMessageChunk = {\n  content: LangChainMessageContent;\n};\n\n// LC stream event v2\ntype LangChainStreamEvent = {\n  event: string;\n  data: any;\n};\n\n/**\nConverts LangChain output streams to AIStream.\n\nThe following streams are supported:\n- `LangChainAIMessageChunk` streams (LangChain `model.stream` output)\n- `string` streams (LangChain `StringOutputParser` output)\n\n@deprecated Use `toDataStream` instead.\n */\nexport function toAIStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: AIStreamCallbacksAndOptions,\n) {\n  return toDataStream(stream, callbacks);\n}\n\n/**\nConverts LangChain output streams to AIStream.\n\nThe following streams are supported:\n- `LangChainAIMessageChunk` streams (LangChain `model.stream` output)\n- `string` streams (LangChain `StringOutputParser` output)\n */\nexport function toDataStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: AIStreamCallbacksAndOptions,\n) {\n  return stream\n    .pipeThrough(\n      new TransformStream<\n        LangChainStreamEvent | LangChainAIMessageChunk | string\n      >({\n        transform: async (value, controller) => {\n          // text stream:\n          if (typeof value === 'string') {\n            controller.enqueue(value);\n            return;\n          }\n\n          // LC stream events v2:\n          if ('event' in value) {\n            // chunk is AIMessage Chunk for on_chat_model_stream event:\n            if (value.event === 'on_chat_model_stream') {\n              forwardAIMessageChunk(\n                value.data?.chunk as LangChainAIMessageChunk,\n                controller,\n              );\n            }\n            return;\n          }\n\n          // AI Message chunk stream:\n          forwardAIMessageChunk(value, controller);\n        },\n      }),\n    )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(createStreamDataTransformer());\n}\n\nexport function toDataStreamResponse(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  options?: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: AIStreamCallbacksAndOptions;\n  },\n) {\n  const dataStream = toDataStream(stream, options?.callbacks);\n  const data = options?.data;\n  const init = options?.init;\n\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nfunction forwardAIMessageChunk(\n  chunk: LangChainAIMessageChunk,\n  controller: TransformStreamDefaultController<any>,\n) {\n  if (typeof chunk.content === 'string') {\n    controller.enqueue(chunk.content);\n  } else {\n    const content: LangChainMessageContentComplex[] = chunk.content;\n    for (const item of content) {\n      if (item.type === 'text') {\n        controller.enqueue(item.text);\n      }\n    }\n  }\n}\n","import { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport { createStreamDataTransformer, StreamData } from './stream-data';\nimport {\n  AIStreamCallbacksAndOptions,\n  createCallbacksTransformer,\n  trimStartOfStreamHelper,\n} from './ai-stream';\n\ntype EngineResponse = {\n  delta: string;\n};\n\nexport function toDataStream(\n  stream: AsyncIterable<EngineResponse>,\n  callbacks?: AIStreamCallbacksAndOptions,\n) {\n  return toReadableStream(stream)\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(createStreamDataTransformer());\n}\n\nexport function toDataStreamResponse(\n  stream: AsyncIterable<EngineResponse>,\n  options: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: AIStreamCallbacksAndOptions;\n  } = {},\n) {\n  const { init, data, callbacks } = options;\n  const dataStream = toDataStream(stream, callbacks);\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nfunction toReadableStream(res: AsyncIterable<EngineResponse>) {\n  const it = res[Symbol.asyncIterator]();\n  const trimStartOfStream = trimStartOfStreamHelper();\n\n  return new ReadableStream<string>({\n    async pull(controller): Promise<void> {\n      const { value, done } = await it.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream(value.delta ?? '');\n      if (text) {\n        controller.enqueue(text);\n      }\n    },\n  });\n}\n","import {\n  type AIStreamCallbacksAndOptions,\n  createCallbacksTransformer,\n} from './ai-stream';\nimport { createStreamDataTransformer } from './stream-data';\n\n/**\n * @deprecated Use [LangChainAdapter](https://sdk.vercel.ai/providers/adapters/langchain) instead.\n */\nexport function LangChainStream(callbacks?: AIStreamCallbacksAndOptions) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n\n  const runs = new Set();\n\n  const handleError = async (e: Error, runId: string) => {\n    runs.delete(runId);\n    await writer.ready;\n    await writer.abort(e);\n  };\n\n  const handleStart = async (runId: string) => {\n    runs.add(runId);\n  };\n\n  const handleEnd = async (runId: string) => {\n    runs.delete(runId);\n\n    if (runs.size === 0) {\n      await writer.ready;\n      await writer.close();\n    }\n  };\n\n  return {\n    stream: stream.readable\n      .pipeThrough(createCallbacksTransformer(callbacks))\n      .pipeThrough(createStreamDataTransformer()),\n    writer,\n    handlers: {\n      handleLLMNewToken: async (token: string) => {\n        await writer.ready;\n        await writer.write(token);\n      },\n      handleLLMStart: async (_llm: any, _prompts: string[], runId: string) => {\n        handleStart(runId);\n      },\n      handleLLMEnd: async (_output: any, runId: string) => {\n        await handleEnd(runId);\n      },\n      handleLLMError: async (e: Error, runId: string) => {\n        await handleError(e, runId);\n      },\n      handleChainStart: async (_chain: any, _inputs: any, runId: string) => {\n        handleStart(runId);\n      },\n      handleChainEnd: async (_outputs: any, runId: string) => {\n        await handleEnd(runId);\n      },\n      handleChainError: async (e: Error, runId: string) => {\n        await handleError(e, runId);\n      },\n      handleToolStart: async (_tool: any, _input: string, runId: string) => {\n        handleStart(runId);\n      },\n      handleToolEnd: async (_output: string, runId: string) => {\n        await handleEnd(runId);\n      },\n      handleToolError: async (e: Error, runId: string) => {\n        await handleError(e, runId);\n      },\n    },\n  };\n}\n","import {\n  createCallbacksTransformer,\n  readableFromAsyncIterable,\n  type AIStreamCallbacksAndOptions,\n} from './ai-stream';\nimport { createStreamDataTransformer } from './stream-data';\n\ninterface ChatCompletionResponseChunk {\n  id: string;\n  object: 'chat.completion.chunk';\n  created: number;\n  model: string;\n  choices: ChatCompletionResponseChunkChoice[];\n}\n\ninterface ChatCompletionResponseChunkChoice {\n  index: number;\n  delta: {\n    role?: string;\n    content?: string;\n    tool_calls?: ToolCalls[];\n  };\n  finish_reason: string;\n}\n\ninterface FunctionCall {\n  name: string;\n  arguments: string;\n}\n\ninterface ToolCalls {\n  id: 'null';\n  type: 'function';\n  function: FunctionCall;\n}\n\nasync function* streamable(stream: AsyncIterable<ChatCompletionResponseChunk>) {\n  for await (const chunk of stream) {\n    const content = chunk.choices[0]?.delta?.content;\n\n    if (content === undefined || content === '') {\n      continue;\n    }\n\n    yield content;\n  }\n}\n\n/*\n * @deprecated Use the [Mistral provider](https://sdk.vercel.ai/providers/ai-sdk-providers/mistral) instead.\n */\nexport function MistralStream(\n  response: AsyncGenerator<ChatCompletionResponseChunk, void, unknown>,\n  callbacks?: AIStreamCallbacksAndOptions,\n): ReadableStream {\n  const stream = readableFromAsyncIterable(streamable(response));\n  return stream\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(createStreamDataTransformer());\n}\n","import {\n  CreateMessage,\n  FunctionCall,\n  JSONValue,\n  ToolCall,\n  createChunkDecoder,\n  formatStreamPart,\n} from '@ai-sdk/ui-utils';\nimport {\n  AIStream,\n  FunctionCallPayload,\n  ToolCallPayload,\n  createCallbacksTransformer,\n  readableFromAsyncIterable,\n  trimStartOfStreamHelper,\n  type AIStreamCallbacksAndOptions,\n} from './ai-stream';\nimport { AzureChatCompletions } from './azure-openai-types';\nimport { createStreamDataTransformer } from './stream-data';\n\nexport type OpenAIStreamCallbacks = AIStreamCallbacksAndOptions & {\n  /**\n   * @example\n   * ```js\n   * const response = await openai.chat.completions.create({\n   *   model: 'gpt-3.5-turbo-0613',\n   *   stream: true,\n   *   messages,\n   *   functions,\n   * })\n   *\n   * const stream = OpenAIStream(response, {\n   *   experimental_onFunctionCall: async (functionCallPayload, createFunctionCallMessages) => {\n   *     // ... run your custom logic here\n   *     const result = await myFunction(functionCallPayload)\n   *\n   *     // Ask for another completion, or return a string to send to the client as an assistant message.\n   *     return await openai.chat.completions.create({\n   *       model: 'gpt-3.5-turbo-0613',\n   *       stream: true,\n   *       // Append the relevant \"assistant\" and \"function\" call messages\n   *       messages: [...messages, ...createFunctionCallMessages(result)],\n   *       functions,\n   *     })\n   *   }\n   * })\n   * ```\n   */\n  experimental_onFunctionCall?: (\n    functionCallPayload: FunctionCallPayload,\n    createFunctionCallMessages: (\n      functionCallResult: JSONValue,\n    ) => CreateMessage[],\n  ) => Promise<\n    Response | undefined | void | string | AsyncIterableOpenAIStreamReturnTypes\n  >;\n  /**\n   * @example\n   * ```js\n   * const response = await openai.chat.completions.create({\n   *   model: 'gpt-3.5-turbo-1106', // or gpt-4-1106-preview\n   *   stream: true,\n   *   messages,\n   *   tools,\n   *   tool_choice: \"auto\", // auto is default, but we'll be explicit\n   * })\n   *\n   * const stream = OpenAIStream(response, {\n   *   experimental_onToolCall: async (toolCallPayload, appendToolCallMessages) => {\n   *    let messages: CreateMessage[] = []\n   *    //   There might be multiple tool calls, so we need to iterate through them\n   *    for (const tool of toolCallPayload.tools) {\n   *     // ... run your custom logic here\n   *     const result = await myFunction(tool.function)\n   *    // Append the relevant \"assistant\" and \"tool\" call messages\n   *     appendToolCallMessage({tool_call_id:tool.id, function_name:tool.function.name, tool_call_result:result})\n   *    }\n   *     // Ask for another completion, or return a string to send to the client as an assistant message.\n   *     return await openai.chat.completions.create({\n   *       model: 'gpt-3.5-turbo-1106', // or gpt-4-1106-preview\n   *       stream: true,\n   *       // Append the results messages, calling appendToolCallMessage without\n   *       // any arguments will jsut return the accumulated messages\n   *       messages: [...messages, ...appendToolCallMessage()],\n   *       tools,\n   *        tool_choice: \"auto\", // auto is default, but we'll be explicit\n   *     })\n   *   }\n   * })\n   * ```\n   */\n  experimental_onToolCall?: (\n    toolCallPayload: ToolCallPayload,\n    appendToolCallMessage: (result?: {\n      tool_call_id: string;\n      function_name: string;\n      tool_call_result: JSONValue;\n    }) => CreateMessage[],\n  ) => Promise<\n    Response | undefined | void | string | AsyncIterableOpenAIStreamReturnTypes\n  >;\n};\n\n// https://github.com/openai/openai-node/blob/07b3504e1c40fd929f4aae1651b83afc19e3baf8/src/resources/chat/completions.ts#L28-L40\ninterface ChatCompletionChunk {\n  id: string;\n  choices: Array<ChatCompletionChunkChoice>;\n  created: number;\n  model: string;\n  object: string;\n}\n\n// https://github.com/openai/openai-node/blob/07b3504e1c40fd929f4aae1651b83afc19e3baf8/src/resources/chat/completions.ts#L43-L49\n// Updated for https://github.com/openai/openai-node/commit/f10c757d831d90407ba47b4659d9cd34b1a35b1d\n// Updated to https://github.com/openai/openai-node/commit/84b43280089eacdf18f171723591856811beddce\ninterface ChatCompletionChunkChoice {\n  delta: ChoiceDelta;\n  finish_reason:\n    | 'stop'\n    | 'length'\n    | 'tool_calls'\n    | 'content_filter'\n    | 'function_call'\n    | null;\n  index: number;\n}\n\n// https://github.com/openai/openai-node/blob/07b3504e1c40fd929f4aae1651b83afc19e3baf8/src/resources/chat/completions.ts#L123-L139\n// Updated to https://github.com/openai/openai-node/commit/84b43280089eacdf18f171723591856811beddce\ninterface ChoiceDelta {\n  /**\n   * The contents of the chunk message.\n   */\n  content?: string | null;\n\n  /**\n   * The name and arguments of a function that should be called, as generated by the\n   * model.\n   */\n  function_call?: FunctionCall;\n\n  /**\n   * The role of the author of this message.\n   */\n  role?: 'system' | 'user' | 'assistant' | 'tool';\n\n  tool_calls?: Array<DeltaToolCall>;\n}\n\n// From https://github.com/openai/openai-node/blob/master/src/resources/chat/completions.ts\n// Updated to https://github.com/openai/openai-node/commit/84b43280089eacdf18f171723591856811beddce\ninterface DeltaToolCall {\n  index: number;\n\n  /**\n   * The ID of the tool call.\n   */\n  id?: string;\n\n  /**\n   * The function that the model called.\n   */\n  function?: ToolCallFunction;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type?: 'function';\n}\n\n// From https://github.com/openai/openai-node/blob/master/src/resources/chat/completions.ts\n// Updated to https://github.com/openai/openai-node/commit/84b43280089eacdf18f171723591856811beddce\ninterface ToolCallFunction {\n  /**\n   * The arguments to call the function with, as generated by the model in JSON\n   * format. Note that the model does not always generate valid JSON, and may\n   * hallucinate parameters not defined by your function schema. Validate the\n   * arguments in your code before calling your function.\n   */\n  arguments?: string;\n\n  /**\n   * The name of the function to call.\n   */\n  name?: string;\n}\n\n/**\n * https://github.com/openai/openai-node/blob/3ec43ee790a2eb6a0ccdd5f25faa23251b0f9b8e/src/resources/completions.ts#L28C1-L64C1\n * Completions API. Streamed and non-streamed responses are the same.\n */\ninterface Completion {\n  /**\n   * A unique identifier for the completion.\n   */\n  id: string;\n\n  /**\n   * The list of completion choices the model generated for the input prompt.\n   */\n  choices: Array<CompletionChoice>;\n\n  /**\n   * The Unix timestamp of when the completion was created.\n   */\n  created: number;\n\n  /**\n   * The model used for completion.\n   */\n  model: string;\n\n  /**\n   * The object type, which is always \"text_completion\"\n   */\n  object: string;\n\n  /**\n   * Usage statistics for the completion request.\n   */\n  usage?: CompletionUsage;\n}\n\ninterface CompletionChoice {\n  /**\n   * The reason the model stopped generating tokens. This will be `stop` if the model\n   * hit a natural stop point or a provided stop sequence, or `length` if the maximum\n   * number of tokens specified in the request was reached.\n   */\n  finish_reason: 'stop' | 'length' | 'content_filter';\n\n  index: number;\n\n  // edited: Removed CompletionChoice.logProbs and replaced with any\n  logprobs: any | null;\n\n  text: string;\n}\n\nexport interface CompletionUsage {\n  /**\n   * Usage statistics for the completion request.\n   */\n\n  /**\n   * Number of tokens in the generated completion.\n   */\n  completion_tokens: number;\n\n  /**\n   * Number of tokens in the prompt.\n   */\n  prompt_tokens: number;\n\n  /**\n   * Total number of tokens used in the request (prompt + completion).\n   */\n  total_tokens: number;\n}\n\n/**\n * Creates a parser function for processing the OpenAI stream data.\n * The parser extracts and trims text content from the JSON data. This parser\n * can handle data for chat or completion models.\n *\n * @return {(data: string) => string | void| { isText: false; content: string }}\n * A parser function that takes a JSON string as input and returns the extracted text content,\n * a complex object with isText: false for function/tool calls, or nothing.\n */\nfunction parseOpenAIStream(): (\n  data: string,\n) => string | void | { isText: false; content: string } {\n  const extract = chunkToText();\n  return data => extract(JSON.parse(data) as OpenAIStreamReturnTypes);\n}\n\n/**\n * Reads chunks from OpenAI's new Streamable interface, which is essentially\n * the same as the old Response body interface with an included SSE parser\n * doing the parsing for us.\n */\nasync function* streamable(stream: AsyncIterableOpenAIStreamReturnTypes) {\n  const extract = chunkToText();\n\n  for await (let chunk of stream) {\n    // convert chunk if it is an Azure chat completion. Azure does not expose all\n    // properties in the interfaces, and also uses camelCase instead of snake_case\n    if ('promptFilterResults' in chunk) {\n      chunk = {\n        id: chunk.id,\n        created: chunk.created.getDate(),\n        object: (chunk as any).object, // not exposed by Azure API\n        model: (chunk as any).model, // not exposed by Azure API\n        choices: chunk.choices.map(choice => ({\n          delta: {\n            content: choice.delta?.content,\n            function_call: choice.delta?.functionCall,\n            role: choice.delta?.role as any,\n            tool_calls: choice.delta?.toolCalls?.length\n              ? choice.delta?.toolCalls?.map((toolCall, index) => ({\n                  index,\n                  id: toolCall.id,\n                  function: toolCall.function,\n                  type: toolCall.type,\n                }))\n              : undefined,\n          },\n          finish_reason: choice.finishReason as any,\n          index: choice.index,\n        })),\n      } satisfies ChatCompletionChunk;\n    }\n\n    const text = extract(chunk);\n\n    if (text) yield text;\n  }\n}\n\nfunction chunkToText(): (\n  chunk: OpenAIStreamReturnTypes,\n) => string | { isText: false; content: string } | void {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn: boolean;\n  return json => {\n    if (isChatCompletionChunk(json)) {\n      const delta = json.choices[0]?.delta;\n      if (delta.function_call?.name) {\n        isFunctionStreamingIn = true;\n        return {\n          isText: false,\n          content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`,\n        };\n      } else if (delta.tool_calls?.[0]?.function?.name) {\n        isFunctionStreamingIn = true;\n        const toolCall = delta.tool_calls[0];\n        if (toolCall.index === 0) {\n          return {\n            isText: false,\n            content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${toolCall.function?.name}\", \"arguments\": \"`,\n          };\n        } else {\n          return {\n            isText: false,\n            content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${toolCall.function?.name}\", \"arguments\": \"`,\n          };\n        }\n      } else if (delta.function_call?.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments(delta.function_call?.arguments),\n        };\n      } else if (delta.tool_calls?.[0]?.function?.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments(delta.tool_calls?.[0]?.function?.arguments),\n        };\n      } else if (\n        isFunctionStreamingIn &&\n        (json.choices[0]?.finish_reason === 'function_call' ||\n          json.choices[0]?.finish_reason === 'stop')\n      ) {\n        isFunctionStreamingIn = false; // Reset the flag\n        return {\n          isText: false,\n          content: '\"}}',\n        };\n      } else if (\n        isFunctionStreamingIn &&\n        json.choices[0]?.finish_reason === 'tool_calls'\n      ) {\n        isFunctionStreamingIn = false; // Reset the flag\n        return {\n          isText: false,\n          content: '\"}}]}',\n        };\n      }\n    }\n\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content\n        ? json.choices[0].delta.content\n        : isCompletion(json)\n        ? json.choices[0].text\n        : '',\n    );\n\n    return text;\n  };\n\n  function cleanupArguments(argumentChunk: string) {\n    let escapedPartialJson = argumentChunk\n      .replace(/\\\\/g, '\\\\\\\\') // Replace backslashes first to prevent double escaping\n      .replace(/\\//g, '\\\\/') // Escape slashes\n      .replace(/\"/g, '\\\\\"') // Escape double quotes\n      .replace(/\\n/g, '\\\\n') // Escape new lines\n      .replace(/\\r/g, '\\\\r') // Escape carriage returns\n      .replace(/\\t/g, '\\\\t') // Escape tabs\n      .replace(/\\f/g, '\\\\f'); // Escape form feeds\n\n    return `${escapedPartialJson}`;\n  }\n}\n\nconst __internal__OpenAIFnMessagesSymbol = Symbol(\n  'internal_openai_fn_messages',\n);\n\ntype AsyncIterableOpenAIStreamReturnTypes =\n  | AsyncIterable<ChatCompletionChunk>\n  | AsyncIterable<Completion>\n  | AsyncIterable<AzureChatCompletions>;\n\ntype ExtractType<T> = T extends AsyncIterable<infer U> ? U : never;\n\ntype OpenAIStreamReturnTypes =\n  ExtractType<AsyncIterableOpenAIStreamReturnTypes>;\n\nfunction isChatCompletionChunk(\n  data: OpenAIStreamReturnTypes,\n): data is ChatCompletionChunk {\n  return (\n    'choices' in data &&\n    data.choices &&\n    data.choices[0] &&\n    'delta' in data.choices[0]\n  );\n}\n\nfunction isCompletion(data: OpenAIStreamReturnTypes): data is Completion {\n  return (\n    'choices' in data &&\n    data.choices &&\n    data.choices[0] &&\n    'text' in data.choices[0]\n  );\n}\n\n/**\n * @deprecated Use the [OpenAI provider](https://sdk.vercel.ai/providers/ai-sdk-providers/openai) instead.\n */\nexport function OpenAIStream(\n  res: Response | AsyncIterableOpenAIStreamReturnTypes,\n  callbacks?: OpenAIStreamCallbacks,\n): ReadableStream {\n  // Annotate the internal `messages` property for recursive function calls\n  const cb:\n    | undefined\n    | (OpenAIStreamCallbacks & {\n        [__internal__OpenAIFnMessagesSymbol]?: CreateMessage[];\n      }) = callbacks;\n\n  let stream: ReadableStream<Uint8Array>;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable(res)).pipeThrough(\n      createCallbacksTransformer(\n        cb?.experimental_onFunctionCall || cb?.experimental_onToolCall\n          ? {\n              ...cb,\n              onFinal: undefined,\n            }\n          : {\n              ...cb,\n            },\n      ),\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      cb?.experimental_onFunctionCall || cb?.experimental_onToolCall\n        ? {\n            ...cb,\n            onFinal: undefined,\n          }\n        : {\n            ...cb,\n          },\n    );\n  }\n\n  if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(createStreamDataTransformer());\n  }\n}\n\nfunction createFunctionCallTransformer(\n  callbacks: OpenAIStreamCallbacks & {\n    [__internal__OpenAIFnMessagesSymbol]?: CreateMessage[];\n  },\n): TransformStream<Uint8Array, Uint8Array> {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = '';\n  let aggregatedFinalCompletionResponse = '';\n  let isFunctionStreamingIn = false;\n\n  let functionCallMessages: CreateMessage[] =\n    callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n\n  const decode = createChunkDecoder();\n\n  return new TransformStream({\n    async transform(chunk, controller): Promise<void> {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n\n      const shouldHandleAsFunction =\n        isFirstChunk &&\n        (message.startsWith('{\"function_call\":') ||\n          message.startsWith('{\"tool_calls\":'));\n\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n\n      // Stream as normal\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart('text', message)),\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller): Promise<void> {\n      try {\n        if (\n          !isFirstChunk &&\n          isFunctionStreamingIn &&\n          (callbacks.experimental_onFunctionCall ||\n            callbacks.experimental_onToolCall)\n        ) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          // Append the function call message to the list\n          let newFunctionCallMessages: CreateMessage[] = [\n            ...functionCallMessages,\n          ];\n\n          let functionResponse:\n            | Response\n            | undefined\n            | void\n            | string\n            | AsyncIterableOpenAIStreamReturnTypes\n            | undefined = undefined;\n          // This callbacks.experimental_onFunctionCall check should not be necessary but TS complains\n          if (callbacks.experimental_onFunctionCall) {\n            // If the user is using the experimental_onFunctionCall callback, they should not be using tools\n            // if payload.function_call is not defined by time we get here we must have gotten a tool response\n            // and the user had defined experimental_onToolCall\n            if (payload.function_call === undefined) {\n              console.warn(\n                'experimental_onFunctionCall should not be defined when using tools',\n              );\n            }\n\n            const argumentsPayload = JSON.parse(\n              payload.function_call.arguments,\n            );\n\n            functionResponse = await callbacks.experimental_onFunctionCall(\n              {\n                name: payload.function_call.name,\n                arguments: argumentsPayload,\n              },\n              result => {\n                // Append the function call request and result messages to the list\n                newFunctionCallMessages = [\n                  ...functionCallMessages,\n                  {\n                    role: 'assistant',\n                    content: '',\n                    function_call: payload.function_call,\n                  },\n                  {\n                    role: 'function',\n                    name: payload.function_call.name,\n                    content: JSON.stringify(result),\n                  },\n                ];\n                // Return it to the user\n                return newFunctionCallMessages;\n              },\n            );\n          }\n          if (callbacks.experimental_onToolCall) {\n            const toolCalls: ToolCallPayload = {\n              tools: [],\n            };\n            for (const tool of payload.tool_calls) {\n              toolCalls.tools.push({\n                id: tool.id,\n                type: 'function',\n                func: {\n                  name: tool.function.name,\n                  arguments: JSON.parse(tool.function.arguments),\n                },\n              });\n            }\n            let responseIndex = 0;\n            try {\n              functionResponse = await callbacks.experimental_onToolCall(\n                toolCalls,\n                result => {\n                  if (result) {\n                    const { tool_call_id, function_name, tool_call_result } =\n                      result;\n                    // Append the function call request and result messages to the list\n                    newFunctionCallMessages = [\n                      ...newFunctionCallMessages,\n                      // Only append the assistant message if it's the first response\n                      ...(responseIndex === 0\n                        ? [\n                            {\n                              role: 'assistant' as const,\n                              content: '',\n                              tool_calls: payload.tool_calls.map(\n                                (tc: ToolCall) => ({\n                                  id: tc.id,\n                                  type: 'function',\n                                  function: {\n                                    name: tc.function.name,\n                                    // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                    arguments: JSON.stringify(\n                                      tc.function.arguments,\n                                    ),\n                                  },\n                                }),\n                              ),\n                            },\n                          ]\n                        : []),\n                      // Append the function call result message\n                      {\n                        role: 'tool',\n                        tool_call_id,\n                        name: function_name,\n                        content: JSON.stringify(tool_call_result),\n                      },\n                    ];\n                    responseIndex++;\n                  }\n                  // Return it to the user\n                  return newFunctionCallMessages;\n                },\n              );\n            } catch (e) {\n              console.error('Error calling experimental_onToolCall:', e);\n            }\n          }\n\n          if (!functionResponse) {\n            // The user didn't do anything with the function call on the server and wants\n            // to either do nothing or run it on the client\n            // so we just return the function call as a message\n            controller.enqueue(\n              textEncoder.encode(\n                formatStreamPart(\n                  payload.function_call ? 'function_call' : 'tool_calls',\n                  // parse to prevent double-encoding:\n                  JSON.parse(aggregatedResponse),\n                ),\n              ),\n            );\n            return;\n          } else if (typeof functionResponse === 'string') {\n            // The user returned a string, so we just return it as a message\n            controller.enqueue(\n              textEncoder.encode(formatStreamPart('text', functionResponse)),\n            );\n            aggregatedFinalCompletionResponse = functionResponse;\n            return;\n          }\n\n          // Recursively:\n\n          // We don't want to trigger onStart or onComplete recursively\n          // so we remove them from the callbacks\n          // see https://github.com/vercel/ai/issues/351\n          const filteredCallbacks: OpenAIStreamCallbacks = {\n            ...callbacks,\n            onStart: undefined,\n          };\n          // We only want onFinal to be called the _last_ time\n          callbacks.onFinal = undefined;\n\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages,\n          } as AIStreamCallbacksAndOptions);\n\n          const reader = openAIStream.getReader();\n\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    },\n  });\n}\n","import { AIStream, type AIStreamCallbacksAndOptions } from './ai-stream';\nimport { createStreamDataTransformer } from './stream-data';\n\n// from replicate SDK\ninterface Prediction {\n  id: string;\n  status: 'starting' | 'processing' | 'succeeded' | 'failed' | 'canceled';\n  version: string;\n  input: object;\n  output?: any;\n  source: 'api' | 'web';\n  error?: any;\n  logs?: string;\n  metrics?: {\n    predict_time?: number;\n  };\n  webhook?: string;\n  webhook_events_filter?: ('start' | 'output' | 'logs' | 'completed')[];\n  created_at: string;\n  updated_at?: string;\n  completed_at?: string;\n  urls: {\n    get: string;\n    cancel: string;\n    stream?: string;\n  };\n}\n\n/**\n * Stream predictions from Replicate.\n * Only certain models are supported and you must pass `stream: true` to\n * replicate.predictions.create().\n * @see https://github.com/replicate/replicate-javascript#streaming\n *\n * @example\n * const response = await replicate.predictions.create({\n *  stream: true,\n *  input: {\n *    prompt: messages.join('\\n')\n *  },\n *  version: '2c1608e18606fad2812020dc541930f2d0495ce32eee50074220b87300bc16e1'\n * })\n *\n * const stream = await ReplicateStream(response)\n * return new StreamingTextResponse(stream)\n *\n */\nexport async function ReplicateStream(\n  res: Prediction,\n  cb?: AIStreamCallbacksAndOptions,\n  options?: {\n    headers?: Record<string, string>;\n  },\n): Promise<ReadableStream> {\n  const url = res.urls?.stream;\n\n  if (!url) {\n    if (res.error) throw new Error(res.error);\n    else throw new Error('Missing stream URL in Replicate response');\n  }\n\n  const eventStream = await fetch(url, {\n    method: 'GET',\n    headers: {\n      Accept: 'text/event-stream',\n      ...options?.headers,\n    },\n  });\n\n  return AIStream(eventStream, undefined, cb).pipeThrough(\n    createStreamDataTransformer(),\n  );\n}\n","import type { ServerResponse } from 'node:http';\nimport { StreamData } from './stream-data';\nimport { mergeStreams } from '../core/util/merge-streams';\n\n/**\n * A utility function to stream a ReadableStream to a Node.js response-like object.\n *\n * @deprecated Use `pipeDataStreamToResponse` (part of `StreamTextResult`) instead.\n */\nexport function streamToResponse(\n  res: ReadableStream,\n  response: ServerResponse,\n  init?: { headers?: Record<string, string>; status?: number },\n  data?: StreamData,\n) {\n  response.writeHead(init?.status ?? 200, {\n    'Content-Type': 'text/plain; charset=utf-8',\n    ...init?.headers,\n  });\n\n  let processedStream = res;\n\n  if (data) {\n    processedStream = mergeStreams(data.stream, res);\n  }\n\n  const reader = processedStream.getReader();\n  function read() {\n    reader.read().then(({ done, value }: { done: boolean; value?: any }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n","import { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport { StreamData } from './stream-data';\n\n/**\n * A utility class for streaming text responses.\n *\n * @deprecated Use `streamText.toDataStreamResponse()` (if you did send StreamData)\n * or a regular `Response` instead (if you did not send any StreamData):\n *\n * ```ts\n * return new Response(stream, {\n *   status: 200,\n *   contentType: 'text/plain; charset=utf-8',\n * })\n * ```\n */\nexport class StreamingTextResponse extends Response {\n  constructor(res: ReadableStream, init?: ResponseInit, data?: StreamData) {\n    let processedStream = res;\n\n    if (data) {\n      processedStream = mergeStreams(data.stream, res);\n    }\n\n    super(processedStream as any, {\n      ...init,\n      status: 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n"],"mappings":"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","names":["StreamData","generateId","import_ui_utils","import_provider_utils","import_ui_utils","import_provider","_a","name","import_api","name","attributes","_a","embedding","usage","embeddings","_a","usage","import_provider_utils","import_provider","name","marker","symbol","_a","_a","import_provider_utils","import_provider","name","marker","symbol","_a","_a","import_provider","name","marker","symbol","_a","import_provider","name","marker","symbol","_a","import_provider","import_provider_utils","import_zod","import_zod","import_zod","import_zod","import_zod","import_zod","_a","import_provider","name","marker","symbol","_a","_a","tool","_a","import_provider","name","marker","symbol","_a","import_provider","import_provider_utils","_a","generateId","_a","span","_b","result","import_provider_utils","import_ui_utils","_a","_a","originalGenerateId","generateId","now","doStreamSpan","_a","error","import_provider_utils","import_provider","import_provider","name","marker","symbol","_a","import_provider","name","marker","symbol","_a","import_ui_utils","name","tool","import_provider_utils","import_ui_utils","tool","tool","originalGenerateId","generateId","_a","tool","span","_b","_c","_d","_e","_f","result","import_provider_utils","result","import_ui_utils","tool","originalGenerateId","now","generateId","stream","warnings","rawResponse","request","doStreamSpan","startTimestampMs","_a","tool","startTimestamp","getErrorMessage","import_provider","import_provider","name","marker","symbol","_a","import_provider","_a","tool","_a","import_ui_utils","StreamData","import_ui_utils","process","_a","stream","_a","createParser","_a","streamable","streamable","_a","createParser","_a","_a","_a","toDataStream","toDataStreamResponse","toDataStream","toDataStreamResponse","_a","streamable","_a","import_ui_utils","streamable","_a","tool","_a","_a","generateId","generateIdImpl"]}