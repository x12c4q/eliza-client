// src/google-vertex-provider.ts
import { generateId, loadSetting } from "@ai-sdk/provider-utils";
import { VertexAI as VertexAI2 } from "@google-cloud/vertexai";

// src/google-vertex-language-model.ts
import {
  NoContentGeneratedError
} from "@ai-sdk/provider";
import { convertAsyncGeneratorToReadableStream } from "@ai-sdk/provider-utils";
import {
  FunctionCallingMode as FunctionCallingMode2
} from "@google-cloud/vertexai";

// src/convert-json-schema-to-openapi-schema.ts
function convertJSONSchemaToOpenAPISchema(jsonSchema) {
  if (typeof jsonSchema === "boolean") {
    return { type: "boolean", properties: {} };
  }
  const {
    type,
    description,
    required,
    properties,
    items,
    allOf,
    anyOf,
    oneOf,
    format,
    const: constValue,
    minLength
  } = jsonSchema;
  const result = {};
  if (description)
    result.description = description;
  if (required)
    result.required = required;
  if (format)
    result.format = format;
  if (constValue !== void 0) {
    result.enum = [constValue];
  }
  if (type) {
    if (Array.isArray(type)) {
      if (type.includes("null")) {
        result.type = type.filter((t) => t !== "null")[0];
        result.nullable = true;
      } else {
        result.type = type;
      }
    } else if (type === "null") {
      result.type = "null";
    } else {
      result.type = type;
    }
  }
  if (properties) {
    result.properties = Object.entries(properties).reduce(
      (acc, [key, value]) => {
        acc[key] = convertJSONSchemaToOpenAPISchema(value);
        return acc;
      },
      {}
    );
  }
  if (items) {
    result.items = Array.isArray(items) ? items.map(convertJSONSchemaToOpenAPISchema) : convertJSONSchemaToOpenAPISchema(items);
  }
  if (allOf) {
    result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema);
  }
  if (anyOf) {
    result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema);
  }
  if (oneOf) {
    result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema);
  }
  if (minLength !== void 0)
    result.minLength = minLength;
  return result;
}

// src/convert-to-google-vertex-content-request.ts
import {
  UnsupportedFunctionalityError
} from "@ai-sdk/provider";
import { convertUint8ArrayToBase64 } from "@ai-sdk/provider-utils";
function convertToGoogleVertexContentRequest(prompt) {
  var _a, _b;
  const systemInstructionParts = [];
  const contents = [];
  let systemMessagesAllowed = true;
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        if (!systemMessagesAllowed) {
          throw new UnsupportedFunctionalityError({
            functionality: "system messages after first user message"
          });
        }
        systemInstructionParts.push({ text: content });
        break;
      }
      case "user": {
        systemMessagesAllowed = false;
        const parts = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              parts.push({ text: part.text });
              break;
            }
            case "image": {
              parts.push(
                part.image instanceof URL ? {
                  fileData: {
                    mimeType: (_a = part.mimeType) != null ? _a : "image/jpeg",
                    fileUri: part.image.toString()
                  }
                } : {
                  inlineData: {
                    mimeType: (_b = part.mimeType) != null ? _b : "image/jpeg",
                    data: convertUint8ArrayToBase64(part.image)
                  }
                }
              );
              break;
            }
            case "file": {
              parts.push(
                part.data instanceof URL ? {
                  fileData: {
                    mimeType: part.mimeType,
                    fileUri: part.data.toString()
                  }
                } : {
                  inlineData: {
                    mimeType: part.mimeType,
                    data: part.data
                  }
                }
              );
              break;
            }
            default: {
              const _exhaustiveCheck = part;
              throw new UnsupportedFunctionalityError({
                functionality: `prompt part: ${_exhaustiveCheck}`
              });
            }
          }
        }
        contents.push({ role: "user", parts });
        break;
      }
      case "assistant": {
        systemMessagesAllowed = false;
        contents.push({
          role: "assistant",
          parts: content.filter((part) => part.type !== "text" || part.text.length > 0).map((part) => {
            switch (part.type) {
              case "text": {
                return { text: part.text };
              }
              case "tool-call": {
                return {
                  functionCall: {
                    name: part.toolName,
                    args: part.args
                  }
                };
              }
              default: {
                const _exhaustiveCheck = part;
                throw new UnsupportedFunctionalityError({
                  functionality: `prompt part: ${_exhaustiveCheck}`
                });
              }
            }
          })
        });
        break;
      }
      case "tool": {
        systemMessagesAllowed = false;
        contents.push({
          role: "user",
          parts: content.map((part) => ({
            functionResponse: {
              name: part.toolName,
              response: part.result
            }
          }))
        });
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new UnsupportedFunctionalityError({
          functionality: `role: ${_exhaustiveCheck}`
        });
      }
    }
  }
  return {
    systemInstruction: systemInstructionParts.length > 0 ? { role: "system", parts: systemInstructionParts } : void 0,
    contents
  };
}

// src/google-vertex-prepare-tools.ts
import {
  FunctionCallingMode
} from "@google-cloud/vertexai";
function prepareTools({
  useSearchGrounding,
  mode
}) {
  var _a, _b;
  const tools = ((_a = mode.tools) == null ? void 0 : _a.length) ? mode.tools : void 0;
  const toolWarnings = [];
  const vertexTools = [];
  if (tools != null) {
    const functionDeclarations = [];
    for (const tool of tools) {
      if (tool.type === "provider-defined") {
        toolWarnings.push({ type: "unsupported-tool", tool });
      } else {
        functionDeclarations.push({
          name: tool.name,
          description: (_b = tool.description) != null ? _b : "",
          parameters: convertJSONSchemaToOpenAPISchema(
            tool.parameters
          )
        });
      }
    }
    vertexTools.push({ functionDeclarations });
  }
  if (useSearchGrounding) {
    vertexTools.push({ googleSearchRetrieval: {} });
  }
  const finalTools = vertexTools.length > 0 ? vertexTools : void 0;
  const toolChoice = mode.toolChoice;
  if (toolChoice == null) {
    return {
      tools: finalTools,
      toolConfig: void 0,
      toolWarnings
    };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
      return {
        tools: finalTools,
        toolConfig: {
          functionCallingConfig: { mode: FunctionCallingMode.AUTO }
        },
        toolWarnings
      };
    case "none":
      return {
        tools: finalTools,
        toolConfig: {
          functionCallingConfig: { mode: FunctionCallingMode.NONE }
        },
        toolWarnings
      };
    case "required":
      return {
        tools: finalTools,
        toolConfig: {
          functionCallingConfig: { mode: FunctionCallingMode.ANY }
        },
        toolWarnings
      };
    case "tool":
      return {
        tools: finalTools,
        toolConfig: {
          functionCallingConfig: {
            mode: FunctionCallingMode.ANY,
            allowedFunctionNames: [toolChoice.toolName]
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new Error(`Unsupported tool choice type: ${_exhaustiveCheck}`);
    }
  }
}

// src/map-google-vertex-finish-reason.ts
function mapGoogleVertexFinishReason({
  finishReason,
  hasToolCalls
}) {
  switch (finishReason) {
    case "STOP":
      return hasToolCalls ? "tool-calls" : "stop";
    case "MAX_TOKENS":
      return "length";
    case "BLOCKLIST":
    case "PROHIBITED_CONTENT":
    case "SPII":
    case "RECITATION":
    case "SAFETY":
      return "content-filter";
    case "FINISH_REASON_UNSPECIFIED":
    case "OTHER":
      return "other";
    default:
      return "unknown";
  }
}

// src/google-vertex-language-model.ts
var GoogleVertexLanguageModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v1";
    this.provider = "google-vertex";
    this.defaultObjectGenerationMode = "json";
    this.supportsImageUrls = false;
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  get supportsObjectGeneration() {
    return this.settings.structuredOutputs !== false;
  }
  async getArgs({
    mode,
    prompt,
    maxTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    headers
  }) {
    var _a, _b;
    const warnings = [];
    if (presencePenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "presencePenalty"
      });
    }
    if (seed != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "seed"
      });
    }
    if (headers != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "headers"
      });
    }
    const generationConfig = {
      // model specific settings:
      topK: topK != null ? topK : this.settings.topK,
      // standardized settings:
      maxOutputTokens: maxTokens,
      frequencyPenalty,
      temperature,
      topP,
      stopSequences,
      // response format:
      responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? "application/json" : void 0,
      responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && // Google Vertex does not support all OpenAPI Schema features,
      // so this is needed as an escape hatch:
      this.supportsObjectGeneration ? convertJSONSchemaToOpenAPISchema(
        responseFormat.schema
      ) : void 0
    };
    const type = mode.type;
    switch (type) {
      case "regular": {
        const { tools, toolConfig, toolWarnings } = prepareTools({
          mode,
          useSearchGrounding: (_a = this.settings.useSearchGrounding) != null ? _a : false
        });
        const configuration = {
          model: this.modelId,
          generationConfig,
          tools,
          toolConfig,
          safetySettings: this.settings.safetySettings
        };
        return {
          model: this.config.vertexAI.getGenerativeModel(configuration),
          contentRequest: convertToGoogleVertexContentRequest(prompt),
          warnings: [...warnings, ...toolWarnings]
        };
      }
      case "object-json": {
        return {
          model: this.config.vertexAI.getGenerativeModel({
            model: this.modelId,
            generationConfig: {
              ...generationConfig,
              responseMimeType: "application/json",
              responseSchema: mode.schema != null && // Google Vertex does not support all OpenAPI Schema features,
              // so this is needed as an escape hatch:
              this.supportsObjectGeneration ? convertJSONSchemaToOpenAPISchema(
                mode.schema
              ) : void 0
            },
            safetySettings: this.settings.safetySettings
          }),
          contentRequest: convertToGoogleVertexContentRequest(prompt),
          warnings
        };
      }
      case "object-tool": {
        const configuration = {
          model: this.modelId,
          generationConfig,
          tools: [
            {
              functionDeclarations: [
                {
                  name: mode.tool.name,
                  description: (_b = mode.tool.description) != null ? _b : "",
                  parameters: convertJSONSchemaToOpenAPISchema(
                    mode.tool.parameters
                  )
                }
              ]
            }
          ],
          toolConfig: {
            functionCallingConfig: { mode: FunctionCallingMode2.ANY }
          },
          safetySettings: this.settings.safetySettings
        };
        return {
          model: this.config.vertexAI.getGenerativeModel(configuration),
          contentRequest: convertToGoogleVertexContentRequest(prompt),
          warnings
        };
      }
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
      }
    }
  }
  supportsUrl(url) {
    return url.protocol === "gs:";
  }
  async doGenerate(options) {
    var _a, _b, _c;
    const { model, contentRequest, warnings } = await this.getArgs(options);
    const { response } = await model.generateContent(contentRequest);
    const firstCandidate = (_a = response.candidates) == null ? void 0 : _a[0];
    if (firstCandidate == null) {
      throw new NoContentGeneratedError({ message: "No candidates returned" });
    }
    const parts = firstCandidate.content.parts;
    const usageMetadata = response.usageMetadata;
    const toolCalls = getToolCallsFromParts({
      parts,
      generateId: this.config.generateId
    });
    return {
      text: getTextFromParts(parts),
      toolCalls,
      finishReason: mapGoogleVertexFinishReason({
        finishReason: firstCandidate.finishReason,
        hasToolCalls: toolCalls != null && toolCalls.length > 0
      }),
      usage: {
        promptTokens: (_b = usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) != null ? _b : NaN,
        completionTokens: (_c = usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) != null ? _c : NaN
      },
      rawCall: {
        rawPrompt: contentRequest,
        rawSettings: {}
      },
      providerMetadata: this.settings.useSearchGrounding ? {
        vertex: {
          groundingMetadata: firstCandidate.groundingMetadata
        }
      } : void 0,
      warnings
    };
  }
  async doStream(options) {
    const { model, contentRequest, warnings } = await this.getArgs(options);
    const { stream } = await model.generateContentStream(contentRequest);
    let finishReason = "unknown";
    let usage = {
      promptTokens: Number.NaN,
      completionTokens: Number.NaN
    };
    const generateId2 = this.config.generateId;
    let hasToolCalls = false;
    let providerMetadata;
    return {
      stream: convertAsyncGeneratorToReadableStream(stream).pipeThrough(
        new TransformStream(
          {
            transform(chunk, controller) {
              var _a, _b, _c;
              const usageMetadata = chunk.usageMetadata;
              if (usageMetadata != null) {
                usage = {
                  promptTokens: (_a = usageMetadata.promptTokenCount) != null ? _a : NaN,
                  completionTokens: (_b = usageMetadata.candidatesTokenCount) != null ? _b : NaN
                };
              }
              const candidate = (_c = chunk.candidates) == null ? void 0 : _c[0];
              if (candidate == null) {
                return;
              }
              if (candidate.finishReason != null) {
                finishReason = mapGoogleVertexFinishReason({
                  finishReason: candidate.finishReason,
                  hasToolCalls
                });
              }
              if (candidate.groundingMetadata != null) {
                providerMetadata = {
                  vertex: {
                    groundingMetadata: candidate.groundingMetadata
                  }
                };
              }
              const content = candidate.content;
              const deltaText = getTextFromParts(content.parts);
              if (deltaText != null) {
                controller.enqueue({
                  type: "text-delta",
                  textDelta: deltaText
                });
              }
              const toolCallDeltas = getToolCallsFromParts({
                parts: content.parts,
                generateId: generateId2
              });
              if (toolCallDeltas != null) {
                for (const toolCall of toolCallDeltas) {
                  controller.enqueue({
                    type: "tool-call-delta",
                    toolCallType: "function",
                    toolCallId: toolCall.toolCallId,
                    toolName: toolCall.toolName,
                    argsTextDelta: toolCall.args
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallType: "function",
                    toolCallId: toolCall.toolCallId,
                    toolName: toolCall.toolName,
                    args: toolCall.args
                  });
                  hasToolCalls = true;
                }
              }
            },
            flush(controller) {
              controller.enqueue({
                type: "finish",
                finishReason,
                usage,
                providerMetadata
              });
            }
          }
        )
      ),
      rawCall: {
        rawPrompt: contentRequest,
        rawSettings: {}
      },
      warnings
    };
  }
};
function getToolCallsFromParts({
  parts,
  generateId: generateId2
}) {
  if (parts == null) {
    return void 0;
  }
  return parts.flatMap(
    (part) => part.functionCall == null ? [] : {
      toolCallType: "function",
      toolCallId: generateId2(),
      toolName: part.functionCall.name,
      args: JSON.stringify(part.functionCall.args)
    }
  );
}
function getTextFromParts(parts) {
  if (parts == null) {
    return void 0;
  }
  const textParts = parts.filter((part) => "text" in part);
  return textParts.length === 0 ? void 0 : textParts.map((part) => part.text).join("");
}

// src/google-vertex-embedding-model.ts
import {
  TooManyEmbeddingValuesForCallError
} from "@ai-sdk/provider";
import {
  combineHeaders,
  createJsonResponseHandler,
  postJsonToApi
} from "@ai-sdk/provider-utils";
import { z as z2 } from "zod";

// src/google-error.ts
import { createJsonErrorResponseHandler } from "@ai-sdk/provider-utils";
import { z } from "zod";
var googleErrorDataSchema = z.object({
  error: z.object({
    code: z.number().nullable(),
    message: z.string(),
    status: z.string()
  })
});
var googleFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: googleErrorDataSchema,
  errorToMessage: (data) => data.error.message
});

// src/google-vertex-embedding-model.ts
var GoogleVertexEmbeddingModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v1";
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    return 2048;
  }
  get supportsParallelCalls() {
    return true;
  }
  async doEmbed({
    values,
    headers,
    abortSignal
  }) {
    if (values.length > this.maxEmbeddingsPerCall) {
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    }
    const { responseHeaders, value: response } = await postJsonToApi({
      url: `https://${this.config.region}-aiplatform.googleapis.com/v1/projects/${this.config.project}/locations/${this.config.region}/publishers/google/models/${this.modelId}:predict`,
      headers: combineHeaders(
        { Authorization: `Bearer ${await this.config.generateAuthToken()}` },
        headers
      ),
      body: {
        instances: values.map((value) => ({ content: value })),
        parameters: {
          outputDimensionality: this.settings.outputDimensionality
        }
      },
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(
        googleVertexTextEmbeddingResponseSchema
      ),
      abortSignal
    });
    return {
      embeddings: response.predictions.map(
        (prediction) => prediction.embeddings.values
      ),
      usage: {
        tokens: response.predictions.reduce(
          (tokenCount, prediction) => tokenCount + prediction.embeddings.statistics.token_count,
          0
        )
      },
      rawResponse: { headers: responseHeaders }
    };
  }
};
var googleVertexTextEmbeddingResponseSchema = z2.object({
  predictions: z2.array(
    z2.object({
      embeddings: z2.object({
        values: z2.array(z2.number()),
        statistics: z2.object({
          token_count: z2.number()
        })
      })
    })
  )
});

// src/google-vertex-provider.ts
function createVertex(options = {}) {
  const loadVertexProject = () => loadSetting({
    settingValue: options.project,
    settingName: "project",
    environmentVariableName: "GOOGLE_VERTEX_PROJECT",
    description: "Google Vertex project"
  });
  const loadVertexLocation = () => loadSetting({
    settingValue: options.location,
    settingName: "location",
    environmentVariableName: "GOOGLE_VERTEX_LOCATION",
    description: "Google Vertex location"
  });
  const createVertexAI = () => {
    var _a, _b;
    const config = {
      project: loadVertexProject(),
      location: loadVertexLocation(),
      googleAuthOptions: options.googleAuthOptions
    };
    return (_b = (_a = options.createVertexAI) == null ? void 0 : _a.call(options, config)) != null ? _b : new VertexAI2(config);
  };
  const createChatModel = (modelId, settings = {}) => {
    var _a;
    return new GoogleVertexLanguageModel(modelId, settings, {
      vertexAI: createVertexAI(),
      generateId: (_a = options.generateId) != null ? _a : generateId
    });
  };
  const createEmbeddingModel = (modelId, settings = {}) => {
    const vertexAI = createVertexAI();
    return new GoogleVertexEmbeddingModel(modelId, settings, {
      provider: "google.vertex",
      region: loadVertexLocation(),
      project: loadVertexProject(),
      generateAuthToken: () => vertexAI.googleAuth.getAccessToken()
    });
  };
  const provider = function(modelId, settings) {
    if (new.target) {
      throw new Error(
        "The Google Vertex AI model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId, settings);
  };
  provider.languageModel = createChatModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  return provider;
}
var vertex = createVertex();
export {
  createVertex,
  vertex
};
//# sourceMappingURL=index.mjs.map